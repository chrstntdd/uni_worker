diff --git a/node_modules/urql/dist/cjs/core.js b/node_modules/urql/dist/cjs/core.js
index 1efa10b..4a9d4a6 100644
--- a/node_modules/urql/dist/cjs/core.js
+++ b/node_modules/urql/dist/cjs/core.js
@@ -253,14 +253,23 @@ var createFetchSource = function (operation) {
       signal: void 0 !== abortController ? abortController.signal : void 0
     });
 
-    executeFetch(operation, fetchOptions).then(function (result) {
-      if (void 0 !== result) {
-        next(result);
-      }
+    var ended = !1;
+    Promise.resolve().then(function () {
+      return ended ? void 0 : executeFetch(operation, fetchOptions);
+    }).then(function (result) {
+      if (!ended) {
+        ended = !0;
+
+        if (result) {
+          next(result);
+        }
 
-      complete();
+        complete();
+      }
     });
     return function () {
+      ended = !0;
+
       if (void 0 !== abortController) {
         abortController.abort();
       }
@@ -630,12 +639,12 @@ exports.subscriptionExchange = function (ref) {
               },
               complete: function () {
                 if (!isComplete) {
+                  isComplete = !0;
                   client.reexecuteOperation(index._extends(index._extends({}, operation), {
                     operationName: "teardown"
                   }));
+                  complete();
                 }
-
-                complete();
               }
             });
             return function () {
diff --git a/node_modules/urql/dist/cjs/core.js.map b/node_modules/urql/dist/cjs/core.js.map
index ea8b31e..8e64745 100644
--- a/node_modules/urql/dist/cjs/core.js.map
+++ b/node_modules/urql/dist/cjs/core.js.map
@@ -1 +1 @@
-{"version":3,"file":"core.js","sources":["../../src/exchanges/ssr.ts","../../src/exchanges/cache.ts","../../src/exchanges/subscription.ts","../../src/exchanges/debug.ts","../../src/exchanges/dedup.ts","../../src/exchanges/fetch.ts","../../src/exchanges/fallback.ts","../../src/exchanges/compose.ts","../../src/exchanges/index.ts","../../src/client.ts"],"sourcesContent":["import { pipe, share, filter, merge, map, tap } from 'wonka';\nimport { Exchange, OperationResult, Operation } from '../types';\nimport { CombinedError } from '../utils';\n\nexport interface SerializedResult {\n  data?: any;\n  error?: {\n    networkError?: string;\n    graphQLErrors: string[];\n  };\n}\n\nexport interface SSRData {\n  [key: string]: SerializedResult;\n}\n\nexport interface SSRExchangeParams {\n  isClient?: boolean;\n  initialState?: SSRData;\n}\n\nexport interface SSRExchange extends Exchange {\n  /** Rehydrates cached data */\n  restoreData(data: SSRData): void;\n  /** Extracts cached data */\n  extractData(): SSRData;\n}\n\nconst shouldSkip = ({ operationName }: Operation) =>\n  operationName !== 'subscription' && operationName !== 'query';\n\n/** Serialize an OperationResult to plain JSON */\nconst serializeResult = ({\n  data,\n  error,\n}: OperationResult): SerializedResult => {\n  const result: SerializedResult = { data, error: undefined };\n  if (error !== undefined) {\n    result.error = {\n      networkError: '' + error.networkError,\n      graphQLErrors: error.graphQLErrors.map(x => '' + x),\n    };\n  }\n\n  return result;\n};\n\n/** Deserialize plain JSON to an OperationResult */\nconst deserializeResult = (\n  operation: Operation,\n  result: SerializedResult\n): OperationResult => {\n  const { error, data } = result;\n  const deserialized: OperationResult = {\n    operation,\n    data,\n    extensions: undefined,\n    error: undefined,\n  };\n  if (error !== undefined) {\n    deserialized.error = new CombinedError({\n      networkError: new Error(error.networkError),\n      graphQLErrors: error.graphQLErrors,\n    });\n  }\n\n  return deserialized;\n};\n\n/** The ssrExchange can be created to capture data during SSR and also to rehydrate it on the client */\nexport const ssrExchange = (params?: SSRExchangeParams): SSRExchange => {\n  const data: SSRData = {};\n\n  const isCached = (operation: Operation) => {\n    return !shouldSkip(operation) && data[operation.key] !== undefined;\n  };\n\n  // The SSR Exchange is a temporary cache that can populate results into data for suspense\n  // On the client it can be used to retrieve these temporary results from a rehydrated cache\n  const ssr: SSRExchange = ({ client, forward }) => ops$ => {\n    // params.isClient tells us whether we're on the client-side\n    // By default we assume that we're on the client if suspense-mode is disabled\n    const isClient =\n      params && typeof params.isClient === 'boolean'\n        ? !!params.isClient\n        : !client.suspense;\n\n    const sharedOps$ = share(ops$);\n\n    let forwardedOps$ = pipe(\n      sharedOps$,\n      filter(op => !isCached(op)),\n      forward\n    );\n\n    // NOTE: Since below we might delete the cached entry after accessing\n    // it once, cachedOps$ needs to be merged after forwardedOps$\n    let cachedOps$ = pipe(\n      sharedOps$,\n      filter(op => isCached(op)),\n      map(op => {\n        const serialized = data[op.key];\n        return deserializeResult(op, serialized);\n      })\n    );\n\n    if (!isClient) {\n      // On the server we cache results in the cache as they're resolved\n      forwardedOps$ = pipe(\n        forwardedOps$,\n        tap((result: OperationResult) => {\n          const { operation } = result;\n          if (!shouldSkip(operation)) {\n            const serialized = serializeResult(result);\n            data[operation.key] = serialized;\n          }\n        })\n      );\n    } else {\n      // On the client we delete results from the cache as they're resolved\n      cachedOps$ = pipe(\n        cachedOps$,\n        tap((result: OperationResult) => {\n          delete data[result.operation.key];\n        })\n      );\n    }\n\n    return merge([forwardedOps$, cachedOps$]);\n  };\n\n  ssr.restoreData = (restore: SSRData) => Object.assign(data, restore);\n  ssr.extractData = () => Object.assign({}, data);\n\n  if (params && params.initialState) {\n    ssr.restoreData(params.initialState);\n  }\n\n  return ssr;\n};\n","/* eslint-disable @typescript-eslint/no-use-before-define */\nimport { filter, map, merge, pipe, share, tap } from 'wonka';\n\nimport { Client } from '../client';\nimport { Exchange, Operation, OperationResult } from '../types';\nimport {\n  addMetadata,\n  collectTypesFromResponse,\n  formatDocument,\n} from '../utils';\n\ntype ResultCache = Map<number, OperationResult>;\n\ninterface OperationCache {\n  [key: string]: Set<number>;\n}\n\nconst shouldSkip = ({ operationName }: Operation) =>\n  operationName !== 'mutation' && operationName !== 'query';\n\nexport const cacheExchange: Exchange = ({ forward, client }) => {\n  const resultCache = new Map() as ResultCache;\n  const operationCache = Object.create(null) as OperationCache;\n\n  // Adds unique typenames to query (for invalidating cache entries)\n  const mapTypeNames = (operation: Operation): Operation => ({\n    ...operation,\n    query: formatDocument(operation.query),\n  });\n\n  const handleAfterMutation = afterMutation(\n    resultCache,\n    operationCache,\n    client\n  );\n\n  const handleAfterQuery = afterQuery(resultCache, operationCache);\n\n  const isOperationCached = operation => {\n    const {\n      key,\n      operationName,\n      context: { requestPolicy },\n    } = operation;\n    return (\n      operationName === 'query' &&\n      requestPolicy !== 'network-only' &&\n      (requestPolicy === 'cache-only' || resultCache.has(key))\n    );\n  };\n\n  return ops$ => {\n    const sharedOps$ = share(ops$);\n\n    const cachedOps$ = pipe(\n      sharedOps$,\n      filter(op => !shouldSkip(op) && isOperationCached(op)),\n      map(operation => {\n        const cachedResult = resultCache.get(operation.key);\n        const result: OperationResult = {\n          ...cachedResult,\n          operation: addMetadata(operation, {\n            cacheOutcome: cachedResult ? 'hit' : 'miss',\n          }),\n        };\n\n        if (operation.context.requestPolicy === 'cache-and-network') {\n          result.stale = true;\n          reexecuteOperation(client, operation);\n        }\n\n        return result;\n      })\n    );\n\n    const forwardedOps$ = pipe(\n      merge([\n        pipe(\n          sharedOps$,\n          filter(op => !shouldSkip(op) && !isOperationCached(op)),\n          map(mapTypeNames)\n        ),\n        pipe(\n          sharedOps$,\n          filter(op => shouldSkip(op))\n        ),\n      ]),\n      map(op => addMetadata(op, { cacheOutcome: 'miss' })),\n      forward,\n      tap(response => {\n        if (\n          response.operation &&\n          response.operation.operationName === 'mutation'\n        ) {\n          handleAfterMutation(response);\n        } else if (\n          response.operation &&\n          response.operation.operationName === 'query'\n        ) {\n          handleAfterQuery(response);\n        }\n      })\n    );\n\n    return merge([cachedOps$, forwardedOps$]);\n  };\n};\n\n// Reexecutes a given operation with the default requestPolicy\nconst reexecuteOperation = (client: Client, operation: Operation) => {\n  return client.reexecuteOperation({\n    ...operation,\n    context: {\n      ...operation.context,\n      requestPolicy: 'network-only',\n    },\n  });\n};\n\n// Invalidates the cache given a mutation's response\nexport const afterMutation = (\n  resultCache: ResultCache,\n  operationCache: OperationCache,\n  client: Client\n) => (response: OperationResult) => {\n  const pendingOperations = new Set<number>();\n\n  collectTypesFromResponse(response.data).forEach(typeName => {\n    const operations =\n      operationCache[typeName] || (operationCache[typeName] = new Set());\n    operations.forEach(key => {\n      pendingOperations.add(key);\n    });\n    operations.clear();\n  });\n\n  pendingOperations.forEach(key => {\n    if (resultCache.has(key)) {\n      const operation = (resultCache.get(key) as OperationResult).operation;\n      resultCache.delete(key);\n      reexecuteOperation(client, operation);\n    }\n  });\n};\n\n// Mark typenames on typenameInvalidate for early invalidation\nconst afterQuery = (\n  resultCache: ResultCache,\n  operationCache: OperationCache\n) => (response: OperationResult) => {\n  const { operation, data, error } = response;\n\n  if (data === undefined || data === null) {\n    return;\n  }\n\n  resultCache.set(operation.key, { operation, data, error });\n\n  collectTypesFromResponse(response.data).forEach(typeName => {\n    const operations =\n      operationCache[typeName] || (operationCache[typeName] = new Set());\n    operations.add(operation.key);\n  });\n};\n","import { print } from 'graphql';\n\nimport {\n  filter,\n  make,\n  merge,\n  mergeMap,\n  pipe,\n  share,\n  Source,\n  takeUntil,\n} from 'wonka';\n\nimport { makeResult, makeErrorResult } from '../utils';\n\nimport {\n  Exchange,\n  ExecutionResult,\n  Operation,\n  OperationContext,\n  OperationResult,\n} from '../types';\n\nexport interface ObserverLike<T> {\n  next: (value: T) => void;\n  error: (err: any) => void;\n  complete: () => void;\n}\n\n/** An abstract observable interface conforming to: https://github.com/tc39/proposal-observable */\nexport interface ObservableLike<T> {\n  subscribe(\n    observer: ObserverLike<T>\n  ): {\n    unsubscribe: () => void;\n  };\n}\n\nexport interface SubscriptionOperation {\n  query: string;\n  variables?: object;\n  key: string;\n  context: OperationContext;\n}\n\nexport type SubscriptionForwarder = (\n  operation: SubscriptionOperation\n) => ObservableLike<ExecutionResult & { extensions?: Record<string, any> }>;\n\n/** This is called to create a subscription and needs to be hooked up to a transport client. */\nexport interface SubscriptionExchangeOpts {\n  // This has been modelled to work with subscription-transport-ws\n  // See: https://github.com/apollographql/subscriptions-transport-ws#requestoptions--observableexecutionresult-returns-observable-to-execute-the-operation\n  forwardSubscription: SubscriptionForwarder;\n}\n\nconst isSubscriptionOperation = (operation: Operation) =>\n  operation.operationName === 'subscription';\n\nexport const subscriptionExchange = ({\n  forwardSubscription,\n}: SubscriptionExchangeOpts): Exchange => ({ client, forward }) => {\n  const createSubscriptionSource = (\n    operation: Operation\n  ): Source<OperationResult> => {\n    // This excludes the query's name as a field although subscription-transport-ws does accept it since it's optional\n    const observableish = forwardSubscription({\n      key: operation.key.toString(36),\n      query: print(operation.query),\n      variables: operation.variables,\n      context: { ...operation.context },\n    });\n\n    return make<OperationResult>(({ next, complete }) => {\n      let isComplete = false;\n\n      const sub = observableish.subscribe({\n        next: result => next(makeResult(operation, result)),\n        error: err => next(makeErrorResult(operation, err)),\n        complete: () => {\n          if (!isComplete) {\n            client.reexecuteOperation({\n              ...operation,\n              operationName: 'teardown',\n            });\n          }\n\n          complete();\n        },\n      });\n\n      return () => {\n        isComplete = true;\n        sub.unsubscribe();\n      };\n    });\n  };\n\n  return ops$ => {\n    const sharedOps$ = share(ops$);\n    const subscriptionResults$ = pipe(\n      sharedOps$,\n      filter(isSubscriptionOperation),\n      mergeMap(operation => {\n        const { key } = operation;\n        const teardown$ = pipe(\n          sharedOps$,\n          filter(op => op.operationName === 'teardown' && op.key === key)\n        );\n\n        return pipe(createSubscriptionSource(operation), takeUntil(teardown$));\n      })\n    );\n\n    const forward$ = pipe(\n      sharedOps$,\n      filter(op => !isSubscriptionOperation(op)),\n      forward\n    );\n\n    return merge([subscriptionResults$, forward$]);\n  };\n};\n","import { pipe, tap } from 'wonka';\nimport { Exchange } from '../types';\n\nexport const debugExchange: Exchange = ({ forward }) => {\n  if (process.env.NODE_ENV === 'production') {\n    return ops$ => forward(ops$);\n  } else {\n    return ops$ =>\n      pipe(\n        ops$,\n        // eslint-disable-next-line no-console\n        tap(op => console.log('[Exchange debug]: Incoming operation: ', op)),\n        forward,\n        tap(result =>\n          // eslint-disable-next-line no-console\n          console.log('[Exchange debug]: Completed operation: ', result)\n        )\n      );\n  }\n};\n","import { filter, pipe, tap } from 'wonka';\nimport { Exchange, Operation, OperationResult } from '../types';\n\n/** A default exchange for debouncing GraphQL requests. */\nexport const dedupExchange: Exchange = ({ forward }) => {\n  const inFlightKeys = new Set<number>();\n\n  const filterIncomingOperation = (operation: Operation) => {\n    const { key, operationName } = operation;\n    if (operationName === 'teardown') {\n      inFlightKeys.delete(key);\n      return true;\n    } else if (operationName !== 'query' && operationName !== 'subscription') {\n      return true;\n    }\n\n    const isInFlight = inFlightKeys.has(key);\n    inFlightKeys.add(key);\n    return !isInFlight;\n  };\n\n  const afterOperationResult = ({ operation }: OperationResult) => {\n    inFlightKeys.delete(operation.key);\n  };\n\n  return ops$ => {\n    const forward$ = pipe(ops$, filter(filterIncomingOperation));\n    return pipe(forward(forward$), tap(afterOperationResult));\n  };\n};\n","/* eslint-disable @typescript-eslint/no-use-before-define */\nimport { Kind, DocumentNode, OperationDefinitionNode, print } from 'graphql';\nimport { filter, make, merge, mergeMap, pipe, share, takeUntil } from 'wonka';\nimport { Exchange, Operation, OperationResult } from '../types';\nimport { makeResult, makeErrorResult } from '../utils';\n\ninterface Body {\n  query: string;\n  variables: void | object;\n  operationName?: string;\n}\n\n/** A default exchange for fetching GraphQL requests. */\nexport const fetchExchange: Exchange = ({ forward }) => {\n  const isOperationFetchable = (operation: Operation) => {\n    const { operationName } = operation;\n    return operationName === 'query' || operationName === 'mutation';\n  };\n\n  return ops$ => {\n    const sharedOps$ = share(ops$);\n    const fetchResults$ = pipe(\n      sharedOps$,\n      filter(isOperationFetchable),\n      mergeMap(operation => {\n        const { key } = operation;\n        const teardown$ = pipe(\n          sharedOps$,\n          filter(op => op.operationName === 'teardown' && op.key === key)\n        );\n\n        return pipe(createFetchSource(operation), takeUntil(teardown$));\n      })\n    );\n\n    const forward$ = pipe(\n      sharedOps$,\n      filter(op => !isOperationFetchable(op)),\n      forward\n    );\n\n    return merge([fetchResults$, forward$]);\n  };\n};\n\nconst getOperationName = (query: DocumentNode): string | null => {\n  const node = query.definitions.find(\n    (node: any): node is OperationDefinitionNode => {\n      return node.kind === Kind.OPERATION_DEFINITION && node.name;\n    }\n  );\n\n  return node !== undefined && node.name ? node.name.value : null;\n};\n\nconst createFetchSource = (operation: Operation) => {\n  if (\n    process.env.NODE_ENV !== 'production' &&\n    operation.operationName === 'subscription'\n  ) {\n    throw new Error(\n      'Received a subscription operation in the httpExchange. You are probably trying to create a subscription. Have you added a subscriptionExchange?'\n    );\n  }\n\n  return make<OperationResult>(({ next, complete }) => {\n    const abortController =\n      typeof AbortController !== 'undefined'\n        ? new AbortController()\n        : undefined;\n\n    const { context } = operation;\n\n    const extraOptions =\n      typeof context.fetchOptions === 'function'\n        ? context.fetchOptions()\n        : context.fetchOptions || {};\n\n    const operationName = getOperationName(operation.query);\n\n    const body: Body = {\n      query: print(operation.query),\n      variables: operation.variables,\n    };\n\n    if (operationName !== null) {\n      body.operationName = operationName;\n    }\n\n    const fetchOptions = {\n      body: JSON.stringify(body),\n      method: 'POST',\n      ...extraOptions,\n      headers: {\n        'content-type': 'application/json',\n        ...extraOptions.headers,\n      },\n      signal:\n        abortController !== undefined ? abortController.signal : undefined,\n    };\n\n    executeFetch(operation, fetchOptions).then(result => {\n      if (result !== undefined) {\n        next(result);\n      }\n\n      complete();\n    });\n\n    return () => {\n      if (abortController !== undefined) {\n        abortController.abort();\n      }\n    };\n  });\n};\n\nconst executeFetch = (operation: Operation, opts: RequestInit) => {\n  const { url, fetch: fetcher } = operation.context;\n\n  let response: Response | undefined;\n\n  return (fetcher || fetch)(url, opts)\n    .then(res => {\n      const { status } = res;\n      const statusRangeEnd = opts.redirect === 'manual' ? 400 : 300;\n      response = res;\n\n      if (status < 200 || status >= statusRangeEnd) {\n        throw new Error(res.statusText);\n      } else {\n        return res.json();\n      }\n    })\n    .then(result => makeResult(operation, result, response))\n    .catch(err => {\n      if (err.name !== 'AbortError') {\n        return makeErrorResult(operation, err, response);\n      }\n    });\n};\n","import { filter, pipe, tap } from 'wonka';\nimport { ExchangeIO, Operation } from '../types';\n\n/** This is always the last exchange in the chain; No operation should ever reach it */\nexport const fallbackExchangeIO: ExchangeIO = ops$ =>\n  pipe(\n    ops$,\n    tap<Operation>(({ operationName }) => {\n      if (\n        operationName !== 'teardown' &&\n        process.env.NODE_ENV !== 'production'\n      ) {\n        console.warn(\n          `No exchange has handled operations of type \"${operationName}\". Check whether you've added an exchange responsible for these operations.`\n        );\n      }\n    }),\n    /* All operations that skipped through the entire exchange chain should be filtered from the output */\n    filter<any>(() => false)\n  );\n","import { Exchange } from '../types';\n\n/** This composes an array of Exchanges into a single ExchangeIO function */\nexport const composeExchanges = (exchanges: Exchange[]): Exchange => {\n  if (exchanges.length === 1) {\n    return exchanges[0];\n  }\n\n  return payload => {\n    return exchanges.reduceRight((forward, exchange) => {\n      return exchange({ client: payload.client, forward });\n    }, payload.forward);\n  };\n};\n","export { ssrExchange } from './ssr';\nexport { cacheExchange } from './cache';\nexport { subscriptionExchange } from './subscription';\nexport { debugExchange } from './debug';\nexport { dedupExchange } from './dedup';\nexport { fetchExchange } from './fetch';\nexport { fallbackExchangeIO } from './fallback';\nexport { composeExchanges } from './compose';\n\nimport { cacheExchange } from './cache';\nimport { dedupExchange } from './dedup';\nimport { fetchExchange } from './fetch';\n\nexport const defaultExchanges = [dedupExchange, cacheExchange, fetchExchange];\n","// This is the entrypoint for the urql/client bundle.\n// It'll be output to dist/es/core.js and dist/cjs/core.js\n// This file also contains the main urql Client\nexport * from './exchanges';\nexport * from './types';\n\nexport {\n  CombinedError,\n  stringifyVariables,\n  createRequest,\n  makeResult,\n  makeErrorResult,\n  formatDocument,\n} from './utils';\n\n/* eslint-disable @typescript-eslint/no-use-before-define */\nimport {\n  filter,\n  makeSubject,\n  onEnd,\n  onStart,\n  pipe,\n  share,\n  Source,\n  take,\n  takeUntil,\n  merge,\n  interval,\n  fromValue,\n  switchMap,\n  publish,\n} from 'wonka';\n\nimport {\n  composeExchanges,\n  defaultExchanges,\n  fallbackExchangeIO,\n} from './exchanges';\n\nimport {\n  Exchange,\n  GraphQLRequest,\n  Operation,\n  OperationContext,\n  OperationResult,\n  OperationType,\n  RequestPolicy,\n  PromisifiedSource,\n} from './types';\n\nimport { createRequest, toSuspenseSource, withPromise } from './utils';\nimport { DocumentNode } from 'graphql';\n\n/** Options for configuring the URQL [client]{@link Client}. */\nexport interface ClientOptions {\n  /** Target endpoint URL such as `https://my-target:8080/graphql`. */\n  url: string;\n  /** Any additional options to pass to fetch. */\n  fetchOptions?: RequestInit | (() => RequestInit);\n  /** An alternative fetch implementation. */\n  fetch?: typeof fetch;\n  /** An ordered array of Exchanges. */\n  exchanges?: Exchange[];\n  /** Activates support for Suspense. */\n  suspense?: boolean;\n  /** The default request policy for requests. */\n  requestPolicy?: RequestPolicy;\n}\n\ninterface ActiveOperations {\n  [operationKey: string]: number;\n}\n\nexport const createClient = (opts: ClientOptions) => new Client(opts);\n\n/** The URQL application-wide client library. Each execute method starts a GraphQL request and returns a stream of results. */\nexport class Client {\n  // These are variables derived from ClientOptions\n  url: string;\n  fetch?: typeof fetch;\n  fetchOptions?: RequestInit | (() => RequestInit);\n  exchange: Exchange;\n  suspense: boolean;\n  requestPolicy: RequestPolicy;\n\n  // These are internals to be used to keep track of operations\n  dispatchOperation: (operation: Operation) => void;\n  operations$: Source<Operation>;\n  results$: Source<OperationResult>;\n  activeOperations = Object.create(null) as ActiveOperations;\n\n  constructor(opts: ClientOptions) {\n    this.url = opts.url;\n    this.fetchOptions = opts.fetchOptions;\n    this.fetch = opts.fetch;\n    this.suspense = !!opts.suspense;\n    this.requestPolicy = opts.requestPolicy || 'cache-first';\n\n    // This subject forms the input of operations; executeOperation may be\n    // called to dispatch a new operation on the subject\n    const { source: operations$, next: nextOperation } = makeSubject<\n      Operation\n    >();\n    this.operations$ = operations$;\n\n    // Internally operations aren't always dispatched immediately\n    // Since exchanges can dispatch and reexecute operations themselves,\n    // if we're inside an exchange we instead queue the operation and flush\n    // them in order after\n    const queuedOperations: Operation[] = [];\n    let isDispatching = false;\n\n    this.dispatchOperation = (operation: Operation) => {\n      queuedOperations.push(operation);\n      if (!isDispatching) {\n        isDispatching = true;\n        let queued;\n        while ((queued = queuedOperations.shift()) !== undefined)\n          nextOperation(queued);\n        isDispatching = false;\n      }\n    };\n\n    const exchanges =\n      opts.exchanges !== undefined ? opts.exchanges : defaultExchanges;\n\n    // All exchange are composed into a single one and are called using the constructed client\n    // and the fallback exchange stream\n    this.exchange = composeExchanges(exchanges);\n\n    // All operations run through the exchanges in a pipeline-like fashion\n    // and this observable then combines all their results\n    this.results$ = share(\n      this.exchange({\n        client: this,\n        forward: fallbackExchangeIO,\n      })(this.operations$)\n    );\n\n    // Prevent the `results$` exchange pipeline from being closed by active\n    // cancellations cascading up from components\n    pipe(this.results$, publish);\n  }\n\n  private createOperationContext = (\n    opts?: Partial<OperationContext>\n  ): OperationContext => ({\n    url: this.url,\n    fetchOptions: this.fetchOptions,\n    fetch: this.fetch,\n    ...opts,\n    requestPolicy: (opts || {}).requestPolicy || this.requestPolicy,\n  });\n\n  createRequestOperation = (\n    type: OperationType,\n    request: GraphQLRequest,\n    opts?: Partial<OperationContext>\n  ): Operation => ({\n    key: request.key,\n    query: request.query,\n    variables: request.variables,\n    operationName: type,\n    context: this.createOperationContext(opts),\n  });\n\n  /** Counts up the active operation key and dispatches the operation */\n  private onOperationStart(operation: Operation) {\n    const { key } = operation;\n    this.activeOperations[key] = (this.activeOperations[key] || 0) + 1;\n    this.dispatchOperation(operation);\n  }\n\n  /** Deletes an active operation's result observable and sends a teardown signal through the exchange pipeline */\n  private onOperationEnd(operation: Operation) {\n    const { key } = operation;\n    const prevActive = this.activeOperations[key] || 0;\n    const newActive = (this.activeOperations[key] =\n      prevActive <= 0 ? 0 : prevActive - 1);\n\n    if (newActive <= 0) {\n      this.dispatchOperation({ ...operation, operationName: 'teardown' });\n    }\n  }\n\n  /** Executes an Operation by sending it through the exchange pipeline It returns an observable that emits all related exchange results and keeps track of this observable's subscribers. A teardown signal will be emitted when no subscribers are listening anymore. */\n  executeRequestOperation(operation: Operation): Source<OperationResult> {\n    const { key, operationName } = operation;\n    const operationResults$ = pipe(\n      this.results$,\n      filter((res: OperationResult) => res.operation.key === key)\n    );\n\n    if (operationName === 'mutation') {\n      // A mutation is always limited to just a single result and is never shared\n      return pipe(\n        operationResults$,\n        onStart<OperationResult>(() => this.dispatchOperation(operation)),\n        take(1)\n      );\n    }\n\n    const teardown$ = pipe(\n      this.operations$,\n      filter(\n        (op: Operation) => op.operationName === 'teardown' && op.key === key\n      )\n    );\n\n    const result$ = pipe(\n      operationResults$,\n      takeUntil(teardown$),\n      onStart<OperationResult>(() => {\n        this.onOperationStart(operation);\n      }),\n      onEnd<OperationResult>(() => {\n        this.onOperationEnd(operation);\n      })\n    );\n\n    return operation.context.suspense !== false &&\n      this.suspense &&\n      operationName === 'query'\n      ? toSuspenseSource<OperationResult>(result$ as Source<OperationResult>)\n      : (result$ as Source<OperationResult>);\n  }\n\n  reexecuteOperation = (operation: Operation) => {\n    // Reexecute operation only if any subscribers are still subscribed to the\n    // operation's exchange results\n    if ((this.activeOperations[operation.key] || 0) > 0) {\n      this.dispatchOperation(operation);\n    }\n  };\n\n  query<Data = any, Variables extends object = {}>(\n    query: DocumentNode | string,\n    variables?: Variables,\n    context?: Partial<OperationContext>\n  ): PromisifiedSource<OperationResult<Data>> {\n    if (!context || typeof context.suspense !== 'boolean') {\n      context = { ...context, suspense: false };\n    }\n\n    return withPromise<OperationResult<Data>>(\n      this.executeQuery(createRequest(query, variables), context)\n    );\n  }\n\n  executeQuery = <Data = any>(\n    query: GraphQLRequest,\n    opts?: Partial<OperationContext>\n  ): Source<OperationResult<Data>> => {\n    const operation = this.createRequestOperation('query', query, opts);\n    const response$ = this.executeRequestOperation(operation);\n    const { pollInterval } = operation.context;\n\n    if (pollInterval) {\n      return pipe(\n        merge([fromValue(0), interval(pollInterval)]),\n        switchMap(() => response$)\n      );\n    }\n\n    return response$;\n  };\n\n  executeSubscription = (\n    query: GraphQLRequest,\n    opts?: Partial<OperationContext>\n  ): Source<OperationResult> => {\n    const operation = this.createRequestOperation('subscription', query, opts);\n    return this.executeRequestOperation(operation);\n  };\n\n  mutation<Data = any, Variables extends object = {}>(\n    query: DocumentNode | string,\n    variables?: Variables,\n    context?: Partial<OperationContext>\n  ): PromisifiedSource<OperationResult<Data>> {\n    return withPromise<OperationResult<Data>>(\n      this.executeMutation(createRequest(query, variables), context)\n    );\n  }\n\n  executeMutation = <Data = any>(\n    query: GraphQLRequest,\n    opts?: Partial<OperationContext>\n  ): Source<OperationResult<Data>> => {\n    const operation = this.createRequestOperation('mutation', query, opts);\n    return this.executeRequestOperation(operation);\n  };\n}\n"],"names":["const","shouldSkip","operationName","x","operation","query","formatDocument","op","addMetadata","cacheOutcome","cacheExchange","resultCache","Map","operationCache","Object","create","mapTypeNames","handleAfterMutation","afterMutation","client","handleAfterQuery","afterQuery","isOperationCached","requestPolicy","has","cachedResult","get","key","result","context","stale","reexecuteOperation","response","ops$","sharedOps$","share","cachedOps$","map","filter","forwardedOps$","tap","forward","merge","delete","pendingOperations","Set","add","collectTypesFromResponse","data","forEach","typeName","operations","clear","set","isSubscriptionOperation","console","log","dedupExchange","inFlightKeys","filterIncomingOperation","isInFlight","afterOperationResult","forward$","fetchExchange","isOperationFetchable","fetchResults$","mergeMap","teardown$","takeUntil","createFetchSource","node","kind","Kind","OPERATION_DEFINITION","name","process","env","NODE_ENV","Error","make","abortController","AbortController","undefined","extraOptions","fetchOptions","definitions","find","value","body","print","variables","JSON","stringify","method","headers","signal","executeFetch","then","next","complete","abort","opts","fetch","res","status","redirect","statusText","json","makeResult","catch","err","makeErrorResult","warn","fallbackExchangeIO","composeExchanges","exchanges","length","payload","reduceRight","exchange","defaultExchanges","Client","url","this","type","request","createOperationContext","activeOperations","dispatchOperation","createRequestOperation","response$","executeRequestOperation","pollInterval","switchMap","fromValue","interval","suspense","makeSubject","operations$","queuedOperations","isDispatching","push","queued","shift","nextOperation","results$","publish","onOperationStart","onOperationEnd","prevActive","operationResults$","take","onStart","result$","onEnd","toSuspenseSource","withPromise","executeQuery","createRequest","mutation","executeMutation","params","isCached","deserialized","extensions","error","CombinedError","networkError","graphQLErrors","deserializeResult","serialized","serializeResult","ssr","isClient","restoreData","restore","_extends","extractData","initialState","subscriptionResults$","observableish","forwardSubscription","toString","isComplete","sub","subscribe","unsubscribe","createSubscriptionSource"],"mappings":";;;;;;;;AA4BAA,IAAMC;;SACc,mBAAlBC,iBAAsD,YAAlBA;;;cAWOC;SAAK,KAAKA;;;ACvBvDH,IAAMC;;SACc,eAAlBC,iBAAkD,YAAlBA;;;gBAOVE;2CACjBA;IACHC,OAAOC,qBAAeF,UAAUC;;;;eA4D1BE;SAAMC,kBAAYD,IAAI;IAAEE,cAAc;;;;eAH/BF;SAAMN,aAAWM;;;IAhErBG;;;MACLC,cAAc,IAAIC;MAClBC,iBAAiBC,OAAOC,OAAO;MAG/BC;MAKAC,sBAAsBC,cAC1BP,aACAE,gBACAM;MAGIC,mBAAmBC,WAAWV,aAAaE;MAE3CS,6BAAoBlB;;WAOJ,uCACA,mBAAlBmB,kBACmB,iBAAlBA,iBAAkCZ,YAAYa;;iBAU3CpB;QACIqB,eAAed,YAAYe,IAAItB,UAAUuB;QACzCC,2CACDH;MACHrB,WAAWI,kBAAYJ,WAAW;QAChCK,cAAcgB,eAAe,QAAQ;;;QAID,wBAApCrB,UAAUyB,QAAQN,eAAuC;MAC3DK,OAAOE,SAAQ;MACfC,mBAAmBZ,QAAQf;;WAGtBwB;;iBAfFrB;YAAON,aAAWM,OAAOe,kBAAkBf;;iBAiC9CyB;QAEAA,SAAS5B,aAC4B,eAArC4B,SAAS5B,UAAUF;MAEnBe,oBAAoBe;WACf,IACLA,SAAS5B,aAC4B,YAArC4B,SAAS5B,UAAUF;MAEnBkB,iBAAiBY;;;iBApBVzB;YAAON,aAAWM,QAAQe,kBAAkBf;;kBA5BpD0B;QACCC,aAAaC,YAAMF;QAEnBG,aAGJC,gBAAAA,CADAC,mBAAAA,CADAJ;QAoBIK,gBAcJC,gBAAAA,CADAC,QADAJ,gBAAAA,CAXAK,YAAM,EAIFL,UAAIrB,aAAJqB,CADAC,mBAAAA,CADAJ,cAMAI,mBAAAA,CADAJ;WAqBCQ,YAAM,EAACN,YAAYG;;;;AAK9BvC,IAAM+B,8BAAsBZ,QAAgBf;SACnCe,OAAOY,qDACT3B;IACHyB,2CACKzB,UAAUyB;MACbN,eAAe;;;;;AAMrB,IAAaL,yBACXP,aACAE,gBACAM;iBAa0BQ;QACpBhB,YAAYa,IAAIG,MAAM;UAClBvB,YAAaO,YAAYe,IAAIC,KAAyBvB;MAC5DO,YAAYgC,OAAOhB;MACnBI,mBAAmBZ,QAAQf;;;kBAhB3B4B;QACEY,oBAAoB,IAAIC;mBAKTlB;MACjBiB,kBAAkBE,IAAInB;;IAJ1BoB,+BAAyBf,SAASgB,MAAMC,kBAAQC;UACxCC,aACJtC,eAAeqC,cAAcrC,eAAeqC,YAAY,IAAIL;MAC9DM,WAAWF;MAGXE,WAAWC;;IAGbR,kBAAkBK;;;;AAUpBjD,IAAMqB,sBACJV,aACAE;kBACImB;;;QAGAgB,QAAAA;;;IAIJrC,YAAY0C,IAAIjD,UAAUuB,KAAK;iBAAEvB;YAAW4C;;;IAE5CD,+BAAyBf,SAASgB,MAAMC,kBAAQC;OAE5CrC,eAAeqC,cAAcrC,eAAeqC,YAAY,IAAIL,MACnDC,IAAI1C,UAAUuB;;;;;ACzG7B3B,IAAMsD,mCAA2BlD;SACH,mBAA5BA,UAAUF;;;gBA2DCK;UAAO+C,wBAAwB/C;;;eCvGhCqB;SAEF2B,QAAQC,IAAI,2CAA2C5B;;;eAJrDrB;SAAMgD,QAAQC,IAAI,0CAA0CjD;;;ICP3DkD;;MACLC,eAAe,IAAIb;MAEnBc,mCAA2BvD;;;QAET,eAAlBF,eAA8B;MAChCwD,aAAaf,OAAOhB;cACb;WACF,IAAsB,YAAlBzB,iBAA+C,mBAAlBA;cAC/B;;QAGH0D,aAAaF,aAAalC,IAAIG;IACpC+B,aAAaZ,IAAInB;YACTiC;;MAGJC;IACJH,aAAaf,qBAAiBhB;;kBAGzBM;QACC6B,WAAsBxB,aAAOqB,wBAAPrB,CAANL;WACSO,UAAIqB,qBAAJrB,CAAnBC,QAAQqB;;;;gBCbQ1D;;SAEH,YAAlBF,iBAA+C,eAAlBA;;;IAH3B6D;;MACLC;iBAuBKzD;YAAOyD,qBAAqBzD;;kBAlBhC0B;QACCC,aAAaC,YAAMF;QACnBgC,gBAGJC,yBAAS9D;;UAED+D,YAEJ7B,uBAAO/B;eAA2B,eAArBA,GAAGL,iBAAgCK,GAAGoB,QAAQA;SAA3DW,CADAJ;aAIwCkC,gBAAUD,UAAVC,CAA9BC,kBAAkBjE;OAPhC8D,CADA5B,aAAO0B,qBAAP1B,CADAJ;QAaI4B,WAGJrB,QADAH,mBAAAA,CADAJ;WAKKQ,YAAM,EAACuB,eAAeH;;;;iBAM5BQ;SACQA,KAAKC,SAASC,aAAKC,wBAAwBH,KAAKI;;;AAO7D1E,IAAMqE,6BAAqBjE;MAEE,iBAAzBuE,QAAQC,IAAIC,YACgB,mBAA5BzE,UAAUF;UAEJ,IAAI4E,MACR;;SAIGC;;;QACCC,kBACuB,sBAApBC,kBACH,IAAIA,uBACJC;;QAIAC,eAC4B,qBAAzBtD,QAAQuD,eACXvD,QAAQuD,iBACRvD,QAAQuD,gBAAgB;QAExBlF,qBA1BQgF,OANVZ,OAgCmClE,UAAUC,MAhChCgF,YAAYC,kBAMFhB,KAAKI,OAAOJ,KAAKI,KAAKa,QAAQ;QANrDjB;QAkCEkB,OAAa;MACjBnF,OAAOoF,cAAMrF,UAAUC;MACvBqF,WAAWtF,UAAUsF;;QAGD,SAAlBxF;MACFsF,KAAKtF,gBAAgBA;;QAGjBkF;MACJI,MAAMG,KAAKC,UAAUJ;MACrBK,QAAQ;OACLV;MACHW;wBACkB;SACbX,aAAaW;MAElBC,aACsBb,MAApBF,kBAAgCA,gBAAgBe,cAASb;;IAG7Dc,aAAa5F,WAAWgF,cAAca,eAAKrE;eAC1BsD,MAAXtD;QACFsE,KAAKtE;;MAGPuE;;;eAIwBjB,MAApBF;QACFA,gBAAgBoB;;;;;;AAMxBpG,IAAMgG,wBAAgB5F,WAAsBiG;YACVjG,UAAUyB;MAEtCG;uBAEesE,gBAAYD,MAC5BJ,eAAKM;;IAGJvE,WAAWuE;QAEPC,SAAS,OAAOA,WAHqB,aAAlBH,KAAKI,WAAwB,MAAM;YAIlD,IAAI3B,MAAMyB,IAAIG;;aAEbH,IAAII;;MAGdV,eAAKrE;WAAUgF,iBAAWxG,WAAWwB,QAAQI;MAC7C6E,gBAAMC;QACY,iBAAbA,IAAIpC;aACCqC,sBAAgB3G,WAAW0G,KAAK9E;;;;;;UCvHzB;;;;;MATI,eAAlB9B,iBACyB,iBAAzByE,QAAQC,IAAIC;IAEZtB,QAAQyD,sDACyC9G;;;;IAT5C+G,8BAAiChF;SAc1CK,qBAXAE,kBAAAA,CADAP;;;ICHSiF,4BAAoBC;MACN,MAArBA,UAAUC;WACLD,UAAU;;kBAGZE;WACEF,UAAUG,sBAAa7E,SAAS8E;aAC9BA,SAAS;QAAEpG,QAAQkG,QAAQlG;iBAAQsB;;QACzC4E,QAAQ5E;;;;ICEF+E,mBAAmB,EAAC/D,eAAe/C,eAAeqD;;IC+DlD0D,SAeX,gBAAYpB;;0BAFOvF,OAAOC,OAAO;yCAwD/BsF;;MAEAqB,KAAKC,OAAKD;MACVtC,cAAcuC,OAAKvC;MACnBkB,OAAOqB,OAAKrB;OACTD;MACH9E,gBAAgB8E,QAAQ,IAAI9E,iBAAiBoG,OAAKpG;;;yCAIlDqG,MACAC,SACAxB;WACe;MACf1E,KAAKkG,QAAQlG;MACbtB,OAAOwH,QAAQxH;MACfqF,WAAWmC,QAAQnC;MACnBxF,eAAe0H;MACf/F,SAAS8F,OAAKG,uBAAuBzB;;;qCAgEjBjG;SAGfuH,OAAKI,iBAAiB3H,UAAUuB,QAAQ,KAAK;MAChDgG,OAAKK,kBAAkB5H;;;+BAmBzBC,OACAgG;QAEMjG,YAAYuH,OAAKM,uBAAuB,SAAS5H,OAAOgG;QACxD6B,YAAYP,OAAKQ,wBAAwB/H;uBACtBA,UAAUyB;QAE/BuG;aAGAC;eAAgBH;SAAhBG,CADA3F,YAAM,EAAC4F,gBAAU,IAAIC,eAASH;;WAK3BF;;sCAIP7H,OACAgG;QAEMjG,YAAYuH,OAAKM,uBAAuB,gBAAgB5H,OAAOgG;WAC9DsB,OAAKQ,wBAAwB/H;;kCAcpCC,OACAgG;QAEMjG,YAAYuH,OAAKM,uBAAuB,YAAY5H,OAAOgG;WAC1DsB,OAAKQ,wBAAwB/H;;OAtM/BsH,MAAMrB,KAAKqB;OACXtC,eAAeiB,KAAKjB;OACpBkB,QAAQD,KAAKC;OACbkC,aAAanC,KAAKmC;OAClBjH,gBAAgB8E,KAAK9E,iBAAiB;YAIUkH;;OAGhDC;MAMCC,mBAAgC;MAClCC,iBAAgB;OAEfZ,6BAAqB5H;IACxBuI,iBAAiBE,KAAKzI;SACjBwI,eAAe;MAClBA,iBAAgB;UACZE;kBAC2C5D,OAAvC4D,SAASH,iBAAiBI;QAChCC,cAAcF;;MAChBF,iBAAgB;;;OASfrB,WAAWL,sBAJKhC,MAAnBmB,KAAKc,YAA0Bd,KAAKc,YAAYK;OAQ7CyB,WAAW9G,YACdwF,KAAKJ,SAAS;IACZpG,QAAQwG;IACRlF,SAASwE;IAFXU,CAGGA,KAAKe;EAKUQ,cAAfvB,KAAKsB;;;iBA0BJE,6CAAiB/I;;OAElB2H,iBAAiBpG,QAAQgG,KAAKI,iBAAiBpG,QAAQ,KAAK;OAC5DqG,kBAAkB5H;;;iBAIjBgJ,yCAAehJ;;MAEfiJ,aAAa1B,KAAKI,iBAAiBpG,QAAQ;OAC9BgG,KAAKI,iBAAiBpG,OACvC0H,cAAc,IAAI,IAAIA,aAAa,MAEpB;SACVrB,oDAAuB5H;MAAWF,eAAe;;;;;iBAK1DiI,2DAAwB/H;;;;MAEhBkJ,oBAEJhH,uBAAQiE;WAAyBA,IAAInG,UAAUuB,QAAQA;KAAvDW,CADAqF,KAAKsB;MAIe,eAAlB/I;WAKAqJ,WAAK,EAALA,CADAC;aAA+B7B,OAAKK,kBAAkB5H;OAAtDoJ,CADAF;;MAMEnF,YAEJ7B,uBACG/B;WAAuC,eAArBA,GAAGL,iBAAgCK,GAAGoB,QAAQA;KADnEW,CADAqF,KAAKe;MAMDe,UAMJC;IACE/B,OAAKyB,eAAehJ;KADtBsJ,CAHAF;IACE7B,OAAKwB,iBAAiB/I;KADxBoJ,CADApF,gBAAUD,UAAVC,CADAkF;UAUoC,MAA/BlJ,UAAUyB,QAAQ2G,YACvBb,KAAKa,YACa,YAAlBtI,gBACEyJ,uBAAkCF,WACjCA;;;iBAWPpJ,uBACEA,SACAqF,WACA7D;OAEKA,WAAuC,oBAArBA,QAAQ2G;IAC7B3G,4CAAeA;MAAS2G,WAAU;;;SAG7BoB,kBACLjC,KAAKkC,aAAaC,oBAAczJ,SAAOqF,YAAY7D;;;iBA8BvDkI,6BACE1J,OACAqF,WACA7D;SAEO+H,kBACLjC,KAAKqC,gBAAgBF,oBAAczJ,OAAOqF,YAAY7D;;;;;;;;;;;;;;;;;;;;;gCAhN/BwE;SAAwB,IAAIoB,OAAOpB;;;;;MNrEjC,iBAAzB1B,QAAQC,IAAIC;yBACP5C;aAAQQ,QAAQR;;;0BAEhBA;aAMHO,gBAAAA,CADAC,QADAD,gBAAAA,CAFAP;;;;;;;;;;;;;+BH6DoBgI;MACpBjH,OAAgB;MAEhBkH,oBAAY9J;YACRH,WAAWG,mBAAsC8E,MAAxBlC,KAAK5C,UAAUuB;;iBAiBvCpB;YAAO2J,SAAS3J;;iBASnBA;oBAnDRH,WACAwB;;UAGMuI,eAAgC;mBACpC/J;;QAEAgK,iBAAYlF;QACZmF,YAAOnF;;eAEKA,MAAVmF;QACFF,aAAaE,QAAQ,IAAIC,oBAAc;UACrCC,cAAc,IAAIzF,MAAMuF,MAAME;UAC9BC,eAAeH,MAAMG;;;aAIlBL;KAoCMM,CAAkBlK,IADNyC,KAAKzC,GAAGoB;;iBAFtBpB;WAAM2J,SAAS3J;;iBAWfqB;;SAEE3B,WAAWG,YAAY;UACpBsK;;YA7EV9I,SAA2B;;UAAQyI,YAAOnF;;iBAClCA,MAAVmF;UACFzI,OAAOyI,QAAQ;YACbE,cAAc,KAAKF,MAAME;YACzBC,eAAeH,MAAMG,cAAcnI;;;eAIhCT;OAqEsB+I,CAAgB/I;MACnCoB,KAAK5C,UAAUuB,OAAO+I;;;iBAQrB9I;WACIoB,KAAKpB,OAAOxB,UAAUuB;;MA5C/BiJ;;;oBAA4C3I;UAG1C4I,WACJZ,UAAqC,oBAApBA,OAAOY,aAClBZ,OAAOY,YACR1J,OAAOqH;UAERtG,aAAaC,YAAMF;UAErBM,gBAGFE,QADAH,mBAAAA,CADAJ;UAOEE,aAGFC,gBAAAA,CADAC,mBAAAA,CADAJ;WAQG2I;QAEHtI,gBAEEC,gBAAAA,CADAD;;QAWFH,aAEEI,gBAAAA,CADAJ;;aAOGM,YAAM,EAACH,eAAeH;;;EAG/BwI,IAAIE,uBAAeC;WAAqBC,eAAchI,MAAM+H;;EAC5DH,IAAIK;WAAoBD,eAAc,IAAIhI;;MAEtCiH,UAAUA,OAAOiB;IACnBN,IAAIE,YAAYb,OAAOiB;;SAGlBN;;;;;;;;oBExCA3I;UACCC,aAAaC,YAAMF;UACnBkJ,uBAGJjH,yBAAS9D;;YAED+D,YAEJ7B,uBAAO/B;iBAA2B,eAArBA,GAAGL,iBAAgCK,GAAGoB,QAAQA;WAA3DW,CADAJ;eAI+CkC,gBAAUD,UAAVC,UA/CrDhE;cAGMgL,gBAAgBC,oBAAoB;YACxC1J,KAAKvB,UAAUuB,IAAI2J,SAAS;YAC5BjL,OAAOoF,cAAMrF,UAAUC;YACvBqF,WAAWtF,UAAUsF;YACrB7D,4BAAczB,UAAUyB;;iBAGnBkD;;;gBACDwG,cAAa;gBAEXC,MAAMJ,cAAcK,UAAU;cAClCvF,eAAMtE;uBAAUsE,KAAKU,iBAAWxG,WAAWwB;;cAC3CyI,gBAAOvD;uBAAOZ,KAAKa,sBAAgB3G,WAAW0G;;cAC9CX;qBACOoF;kBACHpK,OAAOY,qDACF3B;oBACHF,eAAe;;;gBAInBiG;;;;cAKFoF,cAAa;cACbC,IAAIE;;;SAiBQC,CAAyBvL;SAPvC8D,CADA5B,aAAOgB,wBAAPhB,CADAJ;UAaI4B,WAGJrB,QADAH,oBAAAA,CADAJ;aAKKQ,YAAM,EAACyI,sBAAsBrH"}
\ No newline at end of file
+{"version":3,"file":"core.js","sources":["../../src/exchanges/ssr.ts","../../src/exchanges/cache.ts","../../src/exchanges/subscription.ts","../../src/exchanges/debug.ts","../../src/exchanges/dedup.ts","../../src/exchanges/fetch.ts","../../src/exchanges/fallback.ts","../../src/exchanges/compose.ts","../../src/exchanges/index.ts","../../src/client.ts"],"sourcesContent":["import { pipe, share, filter, merge, map, tap } from 'wonka';\nimport { Exchange, OperationResult, Operation } from '../types';\nimport { CombinedError } from '../utils';\n\nexport interface SerializedResult {\n  data?: any;\n  error?: {\n    networkError?: string;\n    graphQLErrors: string[];\n  };\n}\n\nexport interface SSRData {\n  [key: string]: SerializedResult;\n}\n\nexport interface SSRExchangeParams {\n  isClient?: boolean;\n  initialState?: SSRData;\n}\n\nexport interface SSRExchange extends Exchange {\n  /** Rehydrates cached data */\n  restoreData(data: SSRData): void;\n  /** Extracts cached data */\n  extractData(): SSRData;\n}\n\nconst shouldSkip = ({ operationName }: Operation) =>\n  operationName !== 'subscription' && operationName !== 'query';\n\n/** Serialize an OperationResult to plain JSON */\nconst serializeResult = ({\n  data,\n  error,\n}: OperationResult): SerializedResult => {\n  const result: SerializedResult = { data, error: undefined };\n  if (error !== undefined) {\n    result.error = {\n      networkError: '' + error.networkError,\n      graphQLErrors: error.graphQLErrors.map(x => '' + x),\n    };\n  }\n\n  return result;\n};\n\n/** Deserialize plain JSON to an OperationResult */\nconst deserializeResult = (\n  operation: Operation,\n  result: SerializedResult\n): OperationResult => {\n  const { error, data } = result;\n  const deserialized: OperationResult = {\n    operation,\n    data,\n    extensions: undefined,\n    error: undefined,\n  };\n  if (error !== undefined) {\n    deserialized.error = new CombinedError({\n      networkError: new Error(error.networkError),\n      graphQLErrors: error.graphQLErrors,\n    });\n  }\n\n  return deserialized;\n};\n\n/** The ssrExchange can be created to capture data during SSR and also to rehydrate it on the client */\nexport const ssrExchange = (params?: SSRExchangeParams): SSRExchange => {\n  const data: SSRData = {};\n\n  const isCached = (operation: Operation) => {\n    return !shouldSkip(operation) && data[operation.key] !== undefined;\n  };\n\n  // The SSR Exchange is a temporary cache that can populate results into data for suspense\n  // On the client it can be used to retrieve these temporary results from a rehydrated cache\n  const ssr: SSRExchange = ({ client, forward }) => ops$ => {\n    // params.isClient tells us whether we're on the client-side\n    // By default we assume that we're on the client if suspense-mode is disabled\n    const isClient =\n      params && typeof params.isClient === 'boolean'\n        ? !!params.isClient\n        : !client.suspense;\n\n    const sharedOps$ = share(ops$);\n\n    let forwardedOps$ = pipe(\n      sharedOps$,\n      filter(op => !isCached(op)),\n      forward\n    );\n\n    // NOTE: Since below we might delete the cached entry after accessing\n    // it once, cachedOps$ needs to be merged after forwardedOps$\n    let cachedOps$ = pipe(\n      sharedOps$,\n      filter(op => isCached(op)),\n      map(op => {\n        const serialized = data[op.key];\n        return deserializeResult(op, serialized);\n      })\n    );\n\n    if (!isClient) {\n      // On the server we cache results in the cache as they're resolved\n      forwardedOps$ = pipe(\n        forwardedOps$,\n        tap((result: OperationResult) => {\n          const { operation } = result;\n          if (!shouldSkip(operation)) {\n            const serialized = serializeResult(result);\n            data[operation.key] = serialized;\n          }\n        })\n      );\n    } else {\n      // On the client we delete results from the cache as they're resolved\n      cachedOps$ = pipe(\n        cachedOps$,\n        tap((result: OperationResult) => {\n          delete data[result.operation.key];\n        })\n      );\n    }\n\n    return merge([forwardedOps$, cachedOps$]);\n  };\n\n  ssr.restoreData = (restore: SSRData) => Object.assign(data, restore);\n  ssr.extractData = () => Object.assign({}, data);\n\n  if (params && params.initialState) {\n    ssr.restoreData(params.initialState);\n  }\n\n  return ssr;\n};\n","/* eslint-disable @typescript-eslint/no-use-before-define */\nimport { filter, map, merge, pipe, share, tap } from 'wonka';\n\nimport { Client } from '../client';\nimport { Exchange, Operation, OperationResult } from '../types';\nimport {\n  addMetadata,\n  collectTypesFromResponse,\n  formatDocument,\n} from '../utils';\n\ntype ResultCache = Map<number, OperationResult>;\n\ninterface OperationCache {\n  [key: string]: Set<number>;\n}\n\nconst shouldSkip = ({ operationName }: Operation) =>\n  operationName !== 'mutation' && operationName !== 'query';\n\nexport const cacheExchange: Exchange = ({ forward, client }) => {\n  const resultCache = new Map() as ResultCache;\n  const operationCache = Object.create(null) as OperationCache;\n\n  // Adds unique typenames to query (for invalidating cache entries)\n  const mapTypeNames = (operation: Operation): Operation => ({\n    ...operation,\n    query: formatDocument(operation.query),\n  });\n\n  const handleAfterMutation = afterMutation(\n    resultCache,\n    operationCache,\n    client\n  );\n\n  const handleAfterQuery = afterQuery(resultCache, operationCache);\n\n  const isOperationCached = operation => {\n    const {\n      key,\n      operationName,\n      context: { requestPolicy },\n    } = operation;\n    return (\n      operationName === 'query' &&\n      requestPolicy !== 'network-only' &&\n      (requestPolicy === 'cache-only' || resultCache.has(key))\n    );\n  };\n\n  return ops$ => {\n    const sharedOps$ = share(ops$);\n\n    const cachedOps$ = pipe(\n      sharedOps$,\n      filter(op => !shouldSkip(op) && isOperationCached(op)),\n      map(operation => {\n        const cachedResult = resultCache.get(operation.key);\n        const result: OperationResult = {\n          ...cachedResult,\n          operation: addMetadata(operation, {\n            cacheOutcome: cachedResult ? 'hit' : 'miss',\n          }),\n        };\n\n        if (operation.context.requestPolicy === 'cache-and-network') {\n          result.stale = true;\n          reexecuteOperation(client, operation);\n        }\n\n        return result;\n      })\n    );\n\n    const forwardedOps$ = pipe(\n      merge([\n        pipe(\n          sharedOps$,\n          filter(op => !shouldSkip(op) && !isOperationCached(op)),\n          map(mapTypeNames)\n        ),\n        pipe(\n          sharedOps$,\n          filter(op => shouldSkip(op))\n        ),\n      ]),\n      map(op => addMetadata(op, { cacheOutcome: 'miss' })),\n      forward,\n      tap(response => {\n        if (\n          response.operation &&\n          response.operation.operationName === 'mutation'\n        ) {\n          handleAfterMutation(response);\n        } else if (\n          response.operation &&\n          response.operation.operationName === 'query'\n        ) {\n          handleAfterQuery(response);\n        }\n      })\n    );\n\n    return merge([cachedOps$, forwardedOps$]);\n  };\n};\n\n// Reexecutes a given operation with the default requestPolicy\nconst reexecuteOperation = (client: Client, operation: Operation) => {\n  return client.reexecuteOperation({\n    ...operation,\n    context: {\n      ...operation.context,\n      requestPolicy: 'network-only',\n    },\n  });\n};\n\n// Invalidates the cache given a mutation's response\nexport const afterMutation = (\n  resultCache: ResultCache,\n  operationCache: OperationCache,\n  client: Client\n) => (response: OperationResult) => {\n  const pendingOperations = new Set<number>();\n\n  collectTypesFromResponse(response.data).forEach(typeName => {\n    const operations =\n      operationCache[typeName] || (operationCache[typeName] = new Set());\n    operations.forEach(key => {\n      pendingOperations.add(key);\n    });\n    operations.clear();\n  });\n\n  pendingOperations.forEach(key => {\n    if (resultCache.has(key)) {\n      const operation = (resultCache.get(key) as OperationResult).operation;\n      resultCache.delete(key);\n      reexecuteOperation(client, operation);\n    }\n  });\n};\n\n// Mark typenames on typenameInvalidate for early invalidation\nconst afterQuery = (\n  resultCache: ResultCache,\n  operationCache: OperationCache\n) => (response: OperationResult) => {\n  const { operation, data, error } = response;\n\n  if (data === undefined || data === null) {\n    return;\n  }\n\n  resultCache.set(operation.key, { operation, data, error });\n\n  collectTypesFromResponse(response.data).forEach(typeName => {\n    const operations =\n      operationCache[typeName] || (operationCache[typeName] = new Set());\n    operations.add(operation.key);\n  });\n};\n","import { print } from 'graphql';\n\nimport {\n  filter,\n  make,\n  merge,\n  mergeMap,\n  pipe,\n  share,\n  Source,\n  takeUntil,\n} from 'wonka';\n\nimport { makeResult, makeErrorResult } from '../utils';\n\nimport {\n  Exchange,\n  ExecutionResult,\n  Operation,\n  OperationContext,\n  OperationResult,\n} from '../types';\n\nexport interface ObserverLike<T> {\n  next: (value: T) => void;\n  error: (err: any) => void;\n  complete: () => void;\n}\n\n/** An abstract observable interface conforming to: https://github.com/tc39/proposal-observable */\nexport interface ObservableLike<T> {\n  subscribe(\n    observer: ObserverLike<T>\n  ): {\n    unsubscribe: () => void;\n  };\n}\n\nexport interface SubscriptionOperation {\n  query: string;\n  variables?: object;\n  key: string;\n  context: OperationContext;\n}\n\nexport type SubscriptionForwarder = (\n  operation: SubscriptionOperation\n) => ObservableLike<ExecutionResult & { extensions?: Record<string, any> }>;\n\n/** This is called to create a subscription and needs to be hooked up to a transport client. */\nexport interface SubscriptionExchangeOpts {\n  // This has been modelled to work with subscription-transport-ws\n  // See: https://github.com/apollographql/subscriptions-transport-ws#requestoptions--observableexecutionresult-returns-observable-to-execute-the-operation\n  forwardSubscription: SubscriptionForwarder;\n}\n\nconst isSubscriptionOperation = (operation: Operation) =>\n  operation.operationName === 'subscription';\n\nexport const subscriptionExchange = ({\n  forwardSubscription,\n}: SubscriptionExchangeOpts): Exchange => ({ client, forward }) => {\n  const createSubscriptionSource = (\n    operation: Operation\n  ): Source<OperationResult> => {\n    // This excludes the query's name as a field although subscription-transport-ws does accept it since it's optional\n    const observableish = forwardSubscription({\n      key: operation.key.toString(36),\n      query: print(operation.query),\n      variables: operation.variables,\n      context: { ...operation.context },\n    });\n\n    return make<OperationResult>(({ next, complete }) => {\n      let isComplete = false;\n\n      const sub = observableish.subscribe({\n        next: result => next(makeResult(operation, result)),\n        error: err => next(makeErrorResult(operation, err)),\n        complete: () => {\n          if (!isComplete) {\n            isComplete = true;\n            client.reexecuteOperation({\n              ...operation,\n              operationName: 'teardown',\n            });\n\n            complete();\n          }\n        },\n      });\n\n      return () => {\n        isComplete = true;\n        sub.unsubscribe();\n      };\n    });\n  };\n\n  return ops$ => {\n    const sharedOps$ = share(ops$);\n    const subscriptionResults$ = pipe(\n      sharedOps$,\n      filter(isSubscriptionOperation),\n      mergeMap(operation => {\n        const { key } = operation;\n        const teardown$ = pipe(\n          sharedOps$,\n          filter(op => op.operationName === 'teardown' && op.key === key)\n        );\n\n        return pipe(createSubscriptionSource(operation), takeUntil(teardown$));\n      })\n    );\n\n    const forward$ = pipe(\n      sharedOps$,\n      filter(op => !isSubscriptionOperation(op)),\n      forward\n    );\n\n    return merge([subscriptionResults$, forward$]);\n  };\n};\n","import { pipe, tap } from 'wonka';\nimport { Exchange } from '../types';\n\nexport const debugExchange: Exchange = ({ forward }) => {\n  if (process.env.NODE_ENV === 'production') {\n    return ops$ => forward(ops$);\n  } else {\n    return ops$ =>\n      pipe(\n        ops$,\n        // eslint-disable-next-line no-console\n        tap(op => console.log('[Exchange debug]: Incoming operation: ', op)),\n        forward,\n        tap(result =>\n          // eslint-disable-next-line no-console\n          console.log('[Exchange debug]: Completed operation: ', result)\n        )\n      );\n  }\n};\n","import { filter, pipe, tap } from 'wonka';\nimport { Exchange, Operation, OperationResult } from '../types';\n\n/** A default exchange for debouncing GraphQL requests. */\nexport const dedupExchange: Exchange = ({ forward }) => {\n  const inFlightKeys = new Set<number>();\n\n  const filterIncomingOperation = (operation: Operation) => {\n    const { key, operationName } = operation;\n    if (operationName === 'teardown') {\n      inFlightKeys.delete(key);\n      return true;\n    } else if (operationName !== 'query' && operationName !== 'subscription') {\n      return true;\n    }\n\n    const isInFlight = inFlightKeys.has(key);\n    inFlightKeys.add(key);\n    return !isInFlight;\n  };\n\n  const afterOperationResult = ({ operation }: OperationResult) => {\n    inFlightKeys.delete(operation.key);\n  };\n\n  return ops$ => {\n    const forward$ = pipe(ops$, filter(filterIncomingOperation));\n    return pipe(forward(forward$), tap(afterOperationResult));\n  };\n};\n","/* eslint-disable @typescript-eslint/no-use-before-define */\nimport { Kind, DocumentNode, OperationDefinitionNode, print } from 'graphql';\nimport { filter, make, merge, mergeMap, pipe, share, takeUntil } from 'wonka';\nimport { Exchange, Operation, OperationResult } from '../types';\nimport { makeResult, makeErrorResult } from '../utils';\n\ninterface Body {\n  query: string;\n  variables: void | object;\n  operationName?: string;\n}\n\n/** A default exchange for fetching GraphQL requests. */\nexport const fetchExchange: Exchange = ({ forward }) => {\n  const isOperationFetchable = (operation: Operation) => {\n    const { operationName } = operation;\n    return operationName === 'query' || operationName === 'mutation';\n  };\n\n  return ops$ => {\n    const sharedOps$ = share(ops$);\n    const fetchResults$ = pipe(\n      sharedOps$,\n      filter(isOperationFetchable),\n      mergeMap(operation => {\n        const { key } = operation;\n        const teardown$ = pipe(\n          sharedOps$,\n          filter(op => op.operationName === 'teardown' && op.key === key)\n        );\n\n        return pipe(createFetchSource(operation), takeUntil(teardown$));\n      })\n    );\n\n    const forward$ = pipe(\n      sharedOps$,\n      filter(op => !isOperationFetchable(op)),\n      forward\n    );\n\n    return merge([fetchResults$, forward$]);\n  };\n};\n\nconst getOperationName = (query: DocumentNode): string | null => {\n  const node = query.definitions.find(\n    (node: any): node is OperationDefinitionNode => {\n      return node.kind === Kind.OPERATION_DEFINITION && node.name;\n    }\n  );\n\n  return node !== undefined && node.name ? node.name.value : null;\n};\n\nconst createFetchSource = (operation: Operation) => {\n  if (\n    process.env.NODE_ENV !== 'production' &&\n    operation.operationName === 'subscription'\n  ) {\n    throw new Error(\n      'Received a subscription operation in the httpExchange. You are probably trying to create a subscription. Have you added a subscriptionExchange?'\n    );\n  }\n\n  return make<OperationResult>(({ next, complete }) => {\n    const abortController =\n      typeof AbortController !== 'undefined'\n        ? new AbortController()\n        : undefined;\n\n    const { context } = operation;\n\n    const extraOptions =\n      typeof context.fetchOptions === 'function'\n        ? context.fetchOptions()\n        : context.fetchOptions || {};\n\n    const operationName = getOperationName(operation.query);\n\n    const body: Body = {\n      query: print(operation.query),\n      variables: operation.variables,\n    };\n\n    if (operationName !== null) {\n      body.operationName = operationName;\n    }\n\n    const fetchOptions = {\n      body: JSON.stringify(body),\n      method: 'POST',\n      ...extraOptions,\n      headers: {\n        'content-type': 'application/json',\n        ...extraOptions.headers,\n      },\n      signal:\n        abortController !== undefined ? abortController.signal : undefined,\n    };\n\n    let ended = false;\n\n    Promise.resolve()\n      .then(() => (ended ? undefined : executeFetch(operation, fetchOptions)))\n      .then((result: OperationResult | undefined) => {\n        if (!ended) {\n          ended = true;\n          if (result) next(result);\n          complete();\n        }\n      });\n\n    return () => {\n      ended = true;\n      if (abortController !== undefined) {\n        abortController.abort();\n      }\n    };\n  });\n};\n\nconst executeFetch = (\n  operation: Operation,\n  opts: RequestInit\n): Promise<OperationResult> => {\n  const { url, fetch: fetcher } = operation.context;\n  let response: Response | undefined;\n\n  return (fetcher || fetch)(url, opts)\n    .then(res => {\n      const { status } = res;\n      const statusRangeEnd = opts.redirect === 'manual' ? 400 : 300;\n      response = res;\n\n      if (status < 200 || status >= statusRangeEnd) {\n        throw new Error(res.statusText);\n      } else {\n        return res.json();\n      }\n    })\n    .then(result => makeResult(operation, result, response))\n    .catch(err => {\n      if (err.name !== 'AbortError') {\n        return makeErrorResult(operation, err, response);\n      }\n    });\n};\n","import { filter, pipe, tap } from 'wonka';\nimport { ExchangeIO, Operation } from '../types';\n\n/** This is always the last exchange in the chain; No operation should ever reach it */\nexport const fallbackExchangeIO: ExchangeIO = ops$ =>\n  pipe(\n    ops$,\n    tap<Operation>(({ operationName }) => {\n      if (\n        operationName !== 'teardown' &&\n        process.env.NODE_ENV !== 'production'\n      ) {\n        console.warn(\n          `No exchange has handled operations of type \"${operationName}\". Check whether you've added an exchange responsible for these operations.`\n        );\n      }\n    }),\n    /* All operations that skipped through the entire exchange chain should be filtered from the output */\n    filter<any>(() => false)\n  );\n","import { Exchange } from '../types';\n\n/** This composes an array of Exchanges into a single ExchangeIO function */\nexport const composeExchanges = (exchanges: Exchange[]): Exchange => {\n  if (exchanges.length === 1) {\n    return exchanges[0];\n  }\n\n  return payload => {\n    return exchanges.reduceRight((forward, exchange) => {\n      return exchange({ client: payload.client, forward });\n    }, payload.forward);\n  };\n};\n","export { ssrExchange } from './ssr';\nexport { cacheExchange } from './cache';\nexport { subscriptionExchange } from './subscription';\nexport { debugExchange } from './debug';\nexport { dedupExchange } from './dedup';\nexport { fetchExchange } from './fetch';\nexport { fallbackExchangeIO } from './fallback';\nexport { composeExchanges } from './compose';\n\nimport { cacheExchange } from './cache';\nimport { dedupExchange } from './dedup';\nimport { fetchExchange } from './fetch';\n\nexport const defaultExchanges = [dedupExchange, cacheExchange, fetchExchange];\n","// This is the entrypoint for the urql/client bundle.\n// It'll be output to dist/es/core.js and dist/cjs/core.js\n// This file also contains the main urql Client\nexport * from './exchanges';\nexport * from './types';\n\nexport {\n  CombinedError,\n  stringifyVariables,\n  createRequest,\n  makeResult,\n  makeErrorResult,\n  formatDocument,\n} from './utils';\n\n/* eslint-disable @typescript-eslint/no-use-before-define */\nimport {\n  filter,\n  makeSubject,\n  onEnd,\n  onStart,\n  pipe,\n  share,\n  Source,\n  take,\n  takeUntil,\n  merge,\n  interval,\n  fromValue,\n  switchMap,\n  publish,\n} from 'wonka';\n\nimport {\n  composeExchanges,\n  defaultExchanges,\n  fallbackExchangeIO,\n} from './exchanges';\n\nimport {\n  Exchange,\n  GraphQLRequest,\n  Operation,\n  OperationContext,\n  OperationResult,\n  OperationType,\n  RequestPolicy,\n  PromisifiedSource,\n} from './types';\n\nimport { createRequest, toSuspenseSource, withPromise } from './utils';\nimport { DocumentNode } from 'graphql';\n\n/** Options for configuring the URQL [client]{@link Client}. */\nexport interface ClientOptions {\n  /** Target endpoint URL such as `https://my-target:8080/graphql`. */\n  url: string;\n  /** Any additional options to pass to fetch. */\n  fetchOptions?: RequestInit | (() => RequestInit);\n  /** An alternative fetch implementation. */\n  fetch?: typeof fetch;\n  /** An ordered array of Exchanges. */\n  exchanges?: Exchange[];\n  /** Activates support for Suspense. */\n  suspense?: boolean;\n  /** The default request policy for requests. */\n  requestPolicy?: RequestPolicy;\n}\n\ninterface ActiveOperations {\n  [operationKey: string]: number;\n}\n\nexport const createClient = (opts: ClientOptions) => new Client(opts);\n\n/** The URQL application-wide client library. Each execute method starts a GraphQL request and returns a stream of results. */\nexport class Client {\n  // These are variables derived from ClientOptions\n  url: string;\n  fetch?: typeof fetch;\n  fetchOptions?: RequestInit | (() => RequestInit);\n  exchange: Exchange;\n  suspense: boolean;\n  requestPolicy: RequestPolicy;\n\n  // These are internals to be used to keep track of operations\n  dispatchOperation: (operation: Operation) => void;\n  operations$: Source<Operation>;\n  results$: Source<OperationResult>;\n  activeOperations = Object.create(null) as ActiveOperations;\n\n  constructor(opts: ClientOptions) {\n    this.url = opts.url;\n    this.fetchOptions = opts.fetchOptions;\n    this.fetch = opts.fetch;\n    this.suspense = !!opts.suspense;\n    this.requestPolicy = opts.requestPolicy || 'cache-first';\n\n    // This subject forms the input of operations; executeOperation may be\n    // called to dispatch a new operation on the subject\n    const { source: operations$, next: nextOperation } = makeSubject<\n      Operation\n    >();\n    this.operations$ = operations$;\n\n    // Internally operations aren't always dispatched immediately\n    // Since exchanges can dispatch and reexecute operations themselves,\n    // if we're inside an exchange we instead queue the operation and flush\n    // them in order after\n    const queuedOperations: Operation[] = [];\n    let isDispatching = false;\n\n    this.dispatchOperation = (operation: Operation) => {\n      queuedOperations.push(operation);\n      if (!isDispatching) {\n        isDispatching = true;\n        let queued;\n        while ((queued = queuedOperations.shift()) !== undefined)\n          nextOperation(queued);\n        isDispatching = false;\n      }\n    };\n\n    const exchanges =\n      opts.exchanges !== undefined ? opts.exchanges : defaultExchanges;\n\n    // All exchange are composed into a single one and are called using the constructed client\n    // and the fallback exchange stream\n    this.exchange = composeExchanges(exchanges);\n\n    // All operations run through the exchanges in a pipeline-like fashion\n    // and this observable then combines all their results\n    this.results$ = share(\n      this.exchange({\n        client: this,\n        forward: fallbackExchangeIO,\n      })(this.operations$)\n    );\n\n    // Prevent the `results$` exchange pipeline from being closed by active\n    // cancellations cascading up from components\n    pipe(this.results$, publish);\n  }\n\n  private createOperationContext = (\n    opts?: Partial<OperationContext>\n  ): OperationContext => ({\n    url: this.url,\n    fetchOptions: this.fetchOptions,\n    fetch: this.fetch,\n    ...opts,\n    requestPolicy: (opts || {}).requestPolicy || this.requestPolicy,\n  });\n\n  createRequestOperation = (\n    type: OperationType,\n    request: GraphQLRequest,\n    opts?: Partial<OperationContext>\n  ): Operation => ({\n    key: request.key,\n    query: request.query,\n    variables: request.variables,\n    operationName: type,\n    context: this.createOperationContext(opts),\n  });\n\n  /** Counts up the active operation key and dispatches the operation */\n  private onOperationStart(operation: Operation) {\n    const { key } = operation;\n    this.activeOperations[key] = (this.activeOperations[key] || 0) + 1;\n    this.dispatchOperation(operation);\n  }\n\n  /** Deletes an active operation's result observable and sends a teardown signal through the exchange pipeline */\n  private onOperationEnd(operation: Operation) {\n    const { key } = operation;\n    const prevActive = this.activeOperations[key] || 0;\n    const newActive = (this.activeOperations[key] =\n      prevActive <= 0 ? 0 : prevActive - 1);\n\n    if (newActive <= 0) {\n      this.dispatchOperation({ ...operation, operationName: 'teardown' });\n    }\n  }\n\n  /** Executes an Operation by sending it through the exchange pipeline It returns an observable that emits all related exchange results and keeps track of this observable's subscribers. A teardown signal will be emitted when no subscribers are listening anymore. */\n  executeRequestOperation(operation: Operation): Source<OperationResult> {\n    const { key, operationName } = operation;\n    const operationResults$ = pipe(\n      this.results$,\n      filter((res: OperationResult) => res.operation.key === key)\n    );\n\n    if (operationName === 'mutation') {\n      // A mutation is always limited to just a single result and is never shared\n      return pipe(\n        operationResults$,\n        onStart<OperationResult>(() => this.dispatchOperation(operation)),\n        take(1)\n      );\n    }\n\n    const teardown$ = pipe(\n      this.operations$,\n      filter(\n        (op: Operation) => op.operationName === 'teardown' && op.key === key\n      )\n    );\n\n    const result$ = pipe(\n      operationResults$,\n      takeUntil(teardown$),\n      onStart<OperationResult>(() => {\n        this.onOperationStart(operation);\n      }),\n      onEnd<OperationResult>(() => {\n        this.onOperationEnd(operation);\n      })\n    );\n\n    return operation.context.suspense !== false &&\n      this.suspense &&\n      operationName === 'query'\n      ? toSuspenseSource<OperationResult>(result$ as Source<OperationResult>)\n      : (result$ as Source<OperationResult>);\n  }\n\n  reexecuteOperation = (operation: Operation) => {\n    // Reexecute operation only if any subscribers are still subscribed to the\n    // operation's exchange results\n    if ((this.activeOperations[operation.key] || 0) > 0) {\n      this.dispatchOperation(operation);\n    }\n  };\n\n  query<Data = any, Variables extends object = {}>(\n    query: DocumentNode | string,\n    variables?: Variables,\n    context?: Partial<OperationContext>\n  ): PromisifiedSource<OperationResult<Data>> {\n    if (!context || typeof context.suspense !== 'boolean') {\n      context = { ...context, suspense: false };\n    }\n\n    return withPromise<OperationResult<Data>>(\n      this.executeQuery(createRequest(query, variables), context)\n    );\n  }\n\n  executeQuery = <Data = any>(\n    query: GraphQLRequest,\n    opts?: Partial<OperationContext>\n  ): Source<OperationResult<Data>> => {\n    const operation = this.createRequestOperation('query', query, opts);\n    const response$ = this.executeRequestOperation(operation);\n    const { pollInterval } = operation.context;\n\n    if (pollInterval) {\n      return pipe(\n        merge([fromValue(0), interval(pollInterval)]),\n        switchMap(() => response$)\n      );\n    }\n\n    return response$;\n  };\n\n  executeSubscription = (\n    query: GraphQLRequest,\n    opts?: Partial<OperationContext>\n  ): Source<OperationResult> => {\n    const operation = this.createRequestOperation('subscription', query, opts);\n    return this.executeRequestOperation(operation);\n  };\n\n  mutation<Data = any, Variables extends object = {}>(\n    query: DocumentNode | string,\n    variables?: Variables,\n    context?: Partial<OperationContext>\n  ): PromisifiedSource<OperationResult<Data>> {\n    return withPromise<OperationResult<Data>>(\n      this.executeMutation(createRequest(query, variables), context)\n    );\n  }\n\n  executeMutation = <Data = any>(\n    query: GraphQLRequest,\n    opts?: Partial<OperationContext>\n  ): Source<OperationResult<Data>> => {\n    const operation = this.createRequestOperation('mutation', query, opts);\n    return this.executeRequestOperation(operation);\n  };\n}\n"],"names":["const","shouldSkip","operationName","x","operation","query","formatDocument","op","addMetadata","cacheOutcome","cacheExchange","resultCache","Map","operationCache","Object","create","mapTypeNames","handleAfterMutation","afterMutation","client","handleAfterQuery","afterQuery","isOperationCached","requestPolicy","has","cachedResult","get","key","result","context","stale","reexecuteOperation","response","ops$","sharedOps$","share","cachedOps$","map","filter","forwardedOps$","tap","forward","merge","delete","pendingOperations","Set","add","collectTypesFromResponse","data","forEach","typeName","operations","clear","set","isSubscriptionOperation","console","log","dedupExchange","inFlightKeys","filterIncomingOperation","isInFlight","afterOperationResult","forward$","fetchExchange","isOperationFetchable","fetchResults$","mergeMap","teardown$","takeUntil","createFetchSource","node","kind","Kind","OPERATION_DEFINITION","name","process","env","NODE_ENV","Error","make","abortController","AbortController","undefined","extraOptions","fetchOptions","definitions","find","value","body","print","variables","JSON","stringify","method","headers","signal","ended","Promise","resolve","then","executeFetch","next","complete","abort","opts","fetch","res","status","redirect","statusText","json","makeResult","catch","err","makeErrorResult","warn","fallbackExchangeIO","composeExchanges","exchanges","length","payload","reduceRight","exchange","defaultExchanges","Client","url","this","type","request","createOperationContext","activeOperations","dispatchOperation","createRequestOperation","response$","executeRequestOperation","pollInterval","switchMap","fromValue","interval","suspense","makeSubject","operations$","queuedOperations","isDispatching","push","queued","shift","nextOperation","results$","publish","onOperationStart","onOperationEnd","prevActive","operationResults$","take","onStart","result$","onEnd","toSuspenseSource","withPromise","executeQuery","createRequest","mutation","executeMutation","params","isCached","deserialized","extensions","error","CombinedError","networkError","graphQLErrors","deserializeResult","serialized","serializeResult","ssr","isClient","restoreData","restore","_extends","extractData","initialState","subscriptionResults$","observableish","forwardSubscription","toString","isComplete","sub","subscribe","unsubscribe","createSubscriptionSource"],"mappings":";;;;;;;;AA4BAA,IAAMC;;SACc,mBAAlBC,iBAAsD,YAAlBA;;;cAWOC;SAAK,KAAKA;;;ACvBvDH,IAAMC;;SACc,eAAlBC,iBAAkD,YAAlBA;;;gBAOVE;2CACjBA;IACHC,OAAOC,qBAAeF,UAAUC;;;;eA4D1BE;SAAMC,kBAAYD,IAAI;IAAEE,cAAc;;;;eAH/BF;SAAMN,aAAWM;;;IAhErBG;;;MACLC,cAAc,IAAIC;MAClBC,iBAAiBC,OAAOC,OAAO;MAG/BC;MAKAC,sBAAsBC,cAC1BP,aACAE,gBACAM;MAGIC,mBAAmBC,WAAWV,aAAaE;MAE3CS,6BAAoBlB;;WAOJ,uCACA,mBAAlBmB,kBACmB,iBAAlBA,iBAAkCZ,YAAYa;;iBAU3CpB;QACIqB,eAAed,YAAYe,IAAItB,UAAUuB;QACzCC,2CACDH;MACHrB,WAAWI,kBAAYJ,WAAW;QAChCK,cAAcgB,eAAe,QAAQ;;;QAID,wBAApCrB,UAAUyB,QAAQN,eAAuC;MAC3DK,OAAOE,SAAQ;MACfC,mBAAmBZ,QAAQf;;WAGtBwB;;iBAfFrB;YAAON,aAAWM,OAAOe,kBAAkBf;;iBAiC9CyB;QAEAA,SAAS5B,aAC4B,eAArC4B,SAAS5B,UAAUF;MAEnBe,oBAAoBe;WACf,IACLA,SAAS5B,aAC4B,YAArC4B,SAAS5B,UAAUF;MAEnBkB,iBAAiBY;;;iBApBVzB;YAAON,aAAWM,QAAQe,kBAAkBf;;kBA5BpD0B;QACCC,aAAaC,YAAMF;QAEnBG,aAGJC,gBAAAA,CADAC,mBAAAA,CADAJ;QAoBIK,gBAcJC,gBAAAA,CADAC,QADAJ,gBAAAA,CAXAK,YAAM,EAIFL,UAAIrB,aAAJqB,CADAC,mBAAAA,CADAJ,cAMAI,mBAAAA,CADAJ;WAqBCQ,YAAM,EAACN,YAAYG;;;;AAK9BvC,IAAM+B,8BAAsBZ,QAAgBf;SACnCe,OAAOY,qDACT3B;IACHyB,2CACKzB,UAAUyB;MACbN,eAAe;;;;;AAMrB,IAAaL,yBACXP,aACAE,gBACAM;iBAa0BQ;QACpBhB,YAAYa,IAAIG,MAAM;UAClBvB,YAAaO,YAAYe,IAAIC,KAAyBvB;MAC5DO,YAAYgC,OAAOhB;MACnBI,mBAAmBZ,QAAQf;;;kBAhB3B4B;QACEY,oBAAoB,IAAIC;mBAKTlB;MACjBiB,kBAAkBE,IAAInB;;IAJ1BoB,+BAAyBf,SAASgB,MAAMC,kBAAQC;UACxCC,aACJtC,eAAeqC,cAAcrC,eAAeqC,YAAY,IAAIL;MAC9DM,WAAWF;MAGXE,WAAWC;;IAGbR,kBAAkBK;;;;AAUpBjD,IAAMqB,sBACJV,aACAE;kBACImB;;;QAGAgB,QAAAA;;;IAIJrC,YAAY0C,IAAIjD,UAAUuB,KAAK;iBAAEvB;YAAW4C;;;IAE5CD,+BAAyBf,SAASgB,MAAMC,kBAAQC;OAE5CrC,eAAeqC,cAAcrC,eAAeqC,YAAY,IAAIL,MACnDC,IAAI1C,UAAUuB;;;;;ACzG7B3B,IAAMsD,mCAA2BlD;SACH,mBAA5BA,UAAUF;;;gBA4DCK;UAAO+C,wBAAwB/C;;;eCxGhCqB;SAEF2B,QAAQC,IAAI,2CAA2C5B;;;eAJrDrB;SAAMgD,QAAQC,IAAI,0CAA0CjD;;;ICP3DkD;;MACLC,eAAe,IAAIb;MAEnBc,mCAA2BvD;;;QAET,eAAlBF,eAA8B;MAChCwD,aAAaf,OAAOhB;cACb;WACF,IAAsB,YAAlBzB,iBAA+C,mBAAlBA;cAC/B;;QAGH0D,aAAaF,aAAalC,IAAIG;IACpC+B,aAAaZ,IAAInB;YACTiC;;MAGJC;IACJH,aAAaf,qBAAiBhB;;kBAGzBM;QACC6B,WAAsBxB,aAAOqB,wBAAPrB,CAANL;WACSO,UAAIqB,qBAAJrB,CAAnBC,QAAQqB;;;;gBCbQ1D;;SAEH,YAAlBF,iBAA+C,eAAlBA;;;IAH3B6D;;MACLC;iBAuBKzD;YAAOyD,qBAAqBzD;;kBAlBhC0B;QACCC,aAAaC,YAAMF;QACnBgC,gBAGJC,yBAAS9D;;UAED+D,YAEJ7B,uBAAO/B;eAA2B,eAArBA,GAAGL,iBAAgCK,GAAGoB,QAAQA;SAA3DW,CADAJ;aAIwCkC,gBAAUD,UAAVC,CAA9BC,kBAAkBjE;OAPhC8D,CADA5B,aAAO0B,qBAAP1B,CADAJ;QAaI4B,WAGJrB,QADAH,mBAAAA,CADAJ;WAKKQ,YAAM,EAACuB,eAAeH;;;;iBAM5BQ;SACQA,KAAKC,SAASC,aAAKC,wBAAwBH,KAAKI;;;AAO7D1E,IAAMqE,6BAAqBjE;MAEE,iBAAzBuE,QAAQC,IAAIC,YACgB,mBAA5BzE,UAAUF;UAEJ,IAAI4E,MACR;;SAIGC;;;QACCC,kBACuB,sBAApBC,kBACH,IAAIA,uBACJC;;QAIAC,eAC4B,qBAAzBtD,QAAQuD,eACXvD,QAAQuD,iBACRvD,QAAQuD,gBAAgB;QAExBlF,qBA1BQgF,OANVZ,OAgCmClE,UAAUC,MAhChCgF,YAAYC,kBAMFhB,KAAKI,OAAOJ,KAAKI,KAAKa,QAAQ;QANrDjB;QAkCEkB,OAAa;MACjBnF,OAAOoF,cAAMrF,UAAUC;MACvBqF,WAAWtF,UAAUsF;;QAGD,SAAlBxF;MACFsF,KAAKtF,gBAAgBA;;QAGjBkF;MACJI,MAAMG,KAAKC,UAAUJ;MACrBK,QAAQ;OACLV;MACHW;wBACkB;SACbX,aAAaW;MAElBC,aACsBb,MAApBF,kBAAgCA,gBAAgBe,cAASb;;QAGzDc,SAAQ;IAEZC,QAAQC,UACLC;aAAYH,aAAQd,IAAYkB,aAAahG,WAAWgF;QACxDe,eAAMvE;WACAoE,OAAO;QACVA,SAAQ;YACJpE;UAAQyE,KAAKzE;;QACjB0E;;;;MAKJN,SAAQ;eACgBd,MAApBF;QACFA,gBAAgBuB;;;;;;AAMxBvG,IAAMoG,wBACJhG,WACAoG;YAEgCpG,UAAUyB;MACtCG;uBAEeyE,gBAAYD,MAC5BL,eAAKO;;IAGJ1E,WAAW0E;QAEPC,SAAS,OAAOA,WAHqB,aAAlBH,KAAKI,WAAwB,MAAM;YAIlD,IAAI9B,MAAM4B,IAAIG;;aAEbH,IAAII;;MAGdX,eAAKvE;WAAUmF,iBAAW3G,WAAWwB,QAAQI;MAC7CgF,gBAAMC;QACY,iBAAbA,IAAIvC;aACCwC,sBAAgB9G,WAAW6G,KAAKjF;;;;;;UC9HzB;;;;;MATI,eAAlB9B,iBACyB,iBAAzByE,QAAQC,IAAIC;IAEZtB,QAAQ4D,sDACyCjH;;;;IAT5CkH,8BAAiCnF;SAc1CK,qBAXAE,kBAAAA,CADAP;;;ICHSoF,4BAAoBC;MACN,MAArBA,UAAUC;WACLD,UAAU;;kBAGZE;WACEF,UAAUG,sBAAahF,SAASiF;aAC9BA,SAAS;QAAEvG,QAAQqG,QAAQrG;iBAAQsB;;QACzC+E,QAAQ/E;;;;ICEFkF,mBAAmB,EAAClE,eAAe/C,eAAeqD;;IC+DlD6D,SAeX,gBAAYpB;;0BAFO1F,OAAOC,OAAO;yCAwD/ByF;;MAEAqB,KAAKC,OAAKD;MACVzC,cAAc0C,OAAK1C;MACnBqB,OAAOqB,OAAKrB;OACTD;MACHjF,gBAAgBiF,QAAQ,IAAIjF,iBAAiBuG,OAAKvG;;;yCAIlDwG,MACAC,SACAxB;WACe;MACf7E,KAAKqG,QAAQrG;MACbtB,OAAO2H,QAAQ3H;MACfqF,WAAWsC,QAAQtC;MACnBxF,eAAe6H;MACflG,SAASiG,OAAKG,uBAAuBzB;;;qCAgEjBpG;SAGf0H,OAAKI,iBAAiB9H,UAAUuB,QAAQ,KAAK;MAChDmG,OAAKK,kBAAkB/H;;;+BAmBzBC,OACAmG;QAEMpG,YAAY0H,OAAKM,uBAAuB,SAAS/H,OAAOmG;QACxD6B,YAAYP,OAAKQ,wBAAwBlI;uBACtBA,UAAUyB;QAE/B0G;aAGAC;eAAgBH;SAAhBG,CADA9F,YAAM,EAAC+F,gBAAU,IAAIC,eAASH;;WAK3BF;;sCAIPhI,OACAmG;QAEMpG,YAAY0H,OAAKM,uBAAuB,gBAAgB/H,OAAOmG;WAC9DsB,OAAKQ,wBAAwBlI;;kCAcpCC,OACAmG;QAEMpG,YAAY0H,OAAKM,uBAAuB,YAAY/H,OAAOmG;WAC1DsB,OAAKQ,wBAAwBlI;;OAtM/ByH,MAAMrB,KAAKqB;OACXzC,eAAeoB,KAAKpB;OACpBqB,QAAQD,KAAKC;OACbkC,aAAanC,KAAKmC;OAClBpH,gBAAgBiF,KAAKjF,iBAAiB;YAIUqH;;OAGhDC;MAMCC,mBAAgC;MAClCC,iBAAgB;OAEfZ,6BAAqB/H;IACxB0I,iBAAiBE,KAAK5I;SACjB2I,eAAe;MAClBA,iBAAgB;UACZE;kBAC2C/D,OAAvC+D,SAASH,iBAAiBI;QAChCC,cAAcF;;MAChBF,iBAAgB;;;OASfrB,WAAWL,sBAJKnC,MAAnBsB,KAAKc,YAA0Bd,KAAKc,YAAYK;OAQ7CyB,WAAWjH,YACd2F,KAAKJ,SAAS;IACZvG,QAAQ2G;IACRrF,SAAS2E;IAFXU,CAGGA,KAAKe;EAKUQ,cAAfvB,KAAKsB;;;iBA0BJE,6CAAiBlJ;;OAElB8H,iBAAiBvG,QAAQmG,KAAKI,iBAAiBvG,QAAQ,KAAK;OAC5DwG,kBAAkB/H;;;iBAIjBmJ,yCAAenJ;;MAEfoJ,aAAa1B,KAAKI,iBAAiBvG,QAAQ;OAC9BmG,KAAKI,iBAAiBvG,OACvC6H,cAAc,IAAI,IAAIA,aAAa,MAEpB;SACVrB,oDAAuB/H;MAAWF,eAAe;;;;;iBAK1DoI,2DAAwBlI;;;;MAEhBqJ,oBAEJnH,uBAAQoE;WAAyBA,IAAItG,UAAUuB,QAAQA;KAAvDW,CADAwF,KAAKsB;MAIe,eAAlBlJ;WAKAwJ,WAAK,EAALA,CADAC;aAA+B7B,OAAKK,kBAAkB/H;OAAtDuJ,CADAF;;MAMEtF,YAEJ7B,uBACG/B;WAAuC,eAArBA,GAAGL,iBAAgCK,GAAGoB,QAAQA;KADnEW,CADAwF,KAAKe;MAMDe,UAMJC;IACE/B,OAAKyB,eAAenJ;KADtByJ,CAHAF;IACE7B,OAAKwB,iBAAiBlJ;KADxBuJ,CADAvF,gBAAUD,UAAVC,CADAqF;UAUoC,MAA/BrJ,UAAUyB,QAAQ8G,YACvBb,KAAKa,YACa,YAAlBzI,gBACE4J,uBAAkCF,WACjCA;;;iBAWPvJ,uBACEA,SACAqF,WACA7D;OAEKA,WAAuC,oBAArBA,QAAQ8G;IAC7B9G,4CAAeA;MAAS8G,WAAU;;;SAG7BoB,kBACLjC,KAAKkC,aAAaC,oBAAc5J,SAAOqF,YAAY7D;;;iBA8BvDqI,6BACE7J,OACAqF,WACA7D;SAEOkI,kBACLjC,KAAKqC,gBAAgBF,oBAAc5J,OAAOqF,YAAY7D;;;;;;;;;;;;;;;;;;;;;gCAhN/B2E;SAAwB,IAAIoB,OAAOpB;;;;;MNrEjC,iBAAzB7B,QAAQC,IAAIC;yBACP5C;aAAQQ,QAAQR;;;0BAEhBA;aAMHO,gBAAAA,CADAC,QADAD,gBAAAA,CAFAP;;;;;;;;;;;;;+BH6DoBmI;MACpBpH,OAAgB;MAEhBqH,oBAAYjK;YACRH,WAAWG,mBAAsC8E,MAAxBlC,KAAK5C,UAAUuB;;iBAiBvCpB;YAAO8J,SAAS9J;;iBASnBA;oBAnDRH,WACAwB;;UAGM0I,eAAgC;mBACpClK;;QAEAmK,iBAAYrF;QACZsF,YAAOtF;;eAEKA,MAAVsF;QACFF,aAAaE,QAAQ,IAAIC,oBAAc;UACrCC,cAAc,IAAI5F,MAAM0F,MAAME;UAC9BC,eAAeH,MAAMG;;;aAIlBL;KAoCMM,CAAkBrK,IADNyC,KAAKzC,GAAGoB;;iBAFtBpB;WAAM8J,SAAS9J;;iBAWfqB;;SAEE3B,WAAWG,YAAY;UACpByK;;YA7EVjJ,SAA2B;;UAAQ4I,YAAOtF;;iBAClCA,MAAVsF;UACF5I,OAAO4I,QAAQ;YACbE,cAAc,KAAKF,MAAME;YACzBC,eAAeH,MAAMG,cAActI;;;eAIhCT;OAqEsBkJ,CAAgBlJ;MACnCoB,KAAK5C,UAAUuB,OAAOkJ;;;iBAQrBjJ;WACIoB,KAAKpB,OAAOxB,UAAUuB;;MA5C/BoJ;;;oBAA4C9I;UAG1C+I,WACJZ,UAAqC,oBAApBA,OAAOY,aAClBZ,OAAOY,YACR7J,OAAOwH;UAERzG,aAAaC,YAAMF;UAErBM,gBAGFE,QADAH,mBAAAA,CADAJ;UAOEE,aAGFC,gBAAAA,CADAC,mBAAAA,CADAJ;WAQG8I;QAEHzI,gBAEEC,gBAAAA,CADAD;;QAWFH,aAEEI,gBAAAA,CADAJ;;aAOGM,YAAM,EAACH,eAAeH;;;EAG/B2I,IAAIE,uBAAeC;WAAqBC,eAAcnI,MAAMkI;;EAC5DH,IAAIK;WAAoBD,eAAc,IAAInI;;MAEtCoH,UAAUA,OAAOiB;IACnBN,IAAIE,YAAYb,OAAOiB;;SAGlBN;;;;;;;;oBEvCA9I;UACCC,aAAaC,YAAMF;UACnBqJ,uBAGJpH,yBAAS9D;;YAED+D,YAEJ7B,uBAAO/B;iBAA2B,eAArBA,GAAGL,iBAAgCK,GAAGoB,QAAQA;WAA3DW,CADAJ;eAI+CkC,gBAAUD,UAAVC,UAhDrDhE;cAGMmL,gBAAgBC,oBAAoB;YACxC7J,KAAKvB,UAAUuB,IAAI8J,SAAS;YAC5BpL,OAAOoF,cAAMrF,UAAUC;YACvBqF,WAAWtF,UAAUsF;YACrB7D,4BAAczB,UAAUyB;;iBAGnBkD;;;gBACD2G,cAAa;gBAEXC,MAAMJ,cAAcK,UAAU;cAClCvF,eAAMzE;uBAAUyE,KAAKU,iBAAW3G,WAAWwB;;cAC3C4I,gBAAOvD;uBAAOZ,KAAKa,sBAAgB9G,WAAW6G;;cAC9CX;qBACOoF,YAAY;kBACfA,cAAa;kBACbvK,OAAOY,qDACF3B;oBACHF,eAAe;;kBAGjBoG;;;;;cAMJoF,cAAa;cACbC,IAAIE;;;SAiBQC,CAAyB1L;SAPvC8D,CADA5B,aAAOgB,wBAAPhB,CADAJ;UAaI4B,WAGJrB,QADAH,oBAAAA,CADAJ;aAKKQ,YAAM,EAAC4I,sBAAsBxH"}
\ No newline at end of file
diff --git a/node_modules/urql/dist/cjs/min/core.js b/node_modules/urql/dist/cjs/min/core.js
index 3be6222..c4a5703 100644
--- a/node_modules/urql/dist/cjs/min/core.js
+++ b/node_modules/urql/dist/cjs/min/core.js
@@ -1 +1 @@
-"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=require("./index-dddbd19e.js"),t=require("wonka"),r=require("graphql"),n=function(e){var t=e.operationName;return"subscription"!==t&&"query"!==t};function o(e){return""+e}var i=function(e){var t=e.operationName;return"mutation"!==t&&"query"!==t};function a(t){return e._extends(e._extends({},t),{query:e.formatDocument(t.query)})}function u(t){return e.addMetadata(t,{cacheOutcome:"miss"})}function c(e){return i(e)}var s=function(r){var n=r.forward,o=r.client,s=new Map,d=Object.create(null),h=a,x=p(s,d,o),v=l(s,d),m=function(e){var t=e.context.requestPolicy;return"query"===e.operationName&&"network-only"!==t&&("cache-only"===t||s.has(e.key))};function y(t){var r=s.get(t.key),n=e._extends(e._extends({},r),{operation:e.addMetadata(t,{cacheOutcome:r?"hit":"miss"})});return"cache-and-network"===t.context.requestPolicy&&(n.stale=!0,f(o,t)),n}function k(e){return!i(e)&&m(e)}function O(e){e.operation&&"mutation"===e.operation.operationName?x(e):e.operation&&"query"===e.operation.operationName&&v(e)}function q(e){return!i(e)&&!m(e)}return function(e){var r=t.share(e),o=t.map(y)(t.filter(k)(r)),i=t.tap(O)(n(t.map(u)(t.merge([t.map(h)(t.filter(q)(r)),t.filter(c)(r)]))));return t.merge([o,i])}},f=function(t,r){return t.reexecuteOperation(e._extends(e._extends({},r),{context:e._extends(e._extends({},r.context),{requestPolicy:"network-only"})}))},p=function(t,r,n){function o(e){if(t.has(e)){var r=t.get(e).operation;t.delete(e),f(n,r)}}return function(t){var n=new Set;function i(e){n.add(e)}e.collectTypesFromResponse(t.data).forEach(function(e){var t=r[e]||(r[e]=new Set);t.forEach(i),t.clear()}),n.forEach(o)}},l=function(t,r){return function(n){var o=n.operation,i=n.data;null!=i&&(t.set(o.key,{operation:o,data:i,error:n.error}),e.collectTypesFromResponse(n.data).forEach(function(e){(r[e]||(r[e]=new Set)).add(o.key)}))}},d=function(e){return"subscription"===e.operationName};function h(e){return!d(e)}var x=function(e){var r=e.forward,n=new Set,o=function(e){var t=e.key,r=e.operationName;if("teardown"===r)return n.delete(t),!0;if("query"!==r&&"subscription"!==r)return!0;var o=n.has(t);return n.add(t),!o},i=function(e){n.delete(e.operation.key)};return function(e){var n=t.filter(o)(e);return t.tap(i)(r(n))}};function v(e){var t=e.operationName;return"query"===t||"mutation"===t}var m=function(e){var r=e.forward,n=v;function o(e){return!n(e)}return function(e){var i=t.share(e),a=t.mergeMap(function(e){var r=e.key,n=t.filter(function(e){return"teardown"===e.operationName&&e.key===r})(i);return t.takeUntil(n)(k(e))})(t.filter(n)(i)),u=r(t.filter(o)(i));return t.merge([a,u])}};function y(e){return e.kind===r.Kind.OPERATION_DEFINITION&&e.name}var k=function(n){return t.make(function(t){var o,i=t.next,a=t.complete,u="undefined"!=typeof AbortController?new AbortController:void 0,c=n.context,s="function"==typeof c.fetchOptions?c.fetchOptions():c.fetchOptions||{},f=void 0!==(o=n.query.definitions.find(y))&&o.name?o.name.value:null,p={query:r.print(n.query),variables:n.variables};null!==f&&(p.operationName=f);var l=e._extends(e._extends({body:JSON.stringify(p),method:"POST"},s),{headers:e._extends({"content-type":"application/json"},s.headers),signal:void 0!==u?u.signal:void 0});return O(n,l).then(function(e){void 0!==e&&i(e),a()}),function(){void 0!==u&&u.abort()}})},O=function(t,r){var n,o=t.context;return(o.fetch||fetch)(o.url,r).then(function(e){var t=e.status;if(n=e,t<200||t>=("manual"===r.redirect?400:300))throw new Error(e.statusText);return e.json()}).then(function(r){return e.makeResult(t,r,n)}).catch(function(r){if("AbortError"!==r.name)return e.makeErrorResult(t,r,n)})};function q(){return!1}function w(e){}var b=function(e){return t.filter(q)(t.tap(w)(e))},g=function(e){return 1===e.length?e[0]:function(t){return e.reduceRight(function(e,r){return r({client:t.client,forward:e})},t.forward)}},E=[x,s,m],_=function(r){var n=this;this.activeOperations=Object.create(null),this.createOperationContext=function(t){return e._extends(e._extends({url:n.url,fetchOptions:n.fetchOptions,fetch:n.fetch},t),{requestPolicy:(t||{}).requestPolicy||n.requestPolicy})},this.createRequestOperation=function(e,t,r){return{key:t.key,query:t.query,variables:t.variables,operationName:e,context:n.createOperationContext(r)}},this.reexecuteOperation=function(e){(n.activeOperations[e.key]||0)>0&&n.dispatchOperation(e)},this.executeQuery=function(e,r){var o=n.createRequestOperation("query",e,r),i=n.executeRequestOperation(o),a=o.context.pollInterval;return a?t.switchMap(function(){return i})(t.merge([t.fromValue(0),t.interval(a)])):i},this.executeSubscription=function(e,t){var r=n.createRequestOperation("subscription",e,t);return n.executeRequestOperation(r)},this.executeMutation=function(e,t){var r=n.createRequestOperation("mutation",e,t);return n.executeRequestOperation(r)},this.url=r.url,this.fetchOptions=r.fetchOptions,this.fetch=r.fetch,this.suspense=!!r.suspense,this.requestPolicy=r.requestPolicy||"cache-first";var o=t.makeSubject(),i=o.next;this.operations$=o.source;var a=[],u=!1;this.dispatchOperation=function(e){if(a.push(e),!u){var t;for(u=!0;void 0!==(t=a.shift());)i(t);u=!1}},this.exchange=g(void 0!==r.exchanges?r.exchanges:E),this.results$=t.share(this.exchange({client:this,forward:b})(this.operations$)),t.publish(this.results$)};_.prototype.onOperationStart=function(e){var t=e.key;this.activeOperations[t]=(this.activeOperations[t]||0)+1,this.dispatchOperation(e)},_.prototype.onOperationEnd=function(t){var r=t.key,n=this.activeOperations[r]||0;(this.activeOperations[r]=n<=0?0:n-1)<=0&&this.dispatchOperation(e._extends(e._extends({},t),{operationName:"teardown"}))},_.prototype.executeRequestOperation=function(r){var n=this,o=r.key,i=r.operationName,a=t.filter(function(e){return e.operation.key===o})(this.results$);if("mutation"===i)return t.take(1)(t.onStart(function(){return n.dispatchOperation(r)})(a));var u=t.filter(function(e){return"teardown"===e.operationName&&e.key===o})(this.operations$),c=t.onEnd(function(){n.onOperationEnd(r)})(t.onStart(function(){n.onOperationStart(r)})(t.takeUntil(u)(a)));return!1!==r.context.suspense&&this.suspense&&"query"===i?e.toSuspenseSource(c):c},_.prototype.query=function(t,r,n){return n&&"boolean"==typeof n.suspense||(n=e._extends(e._extends({},n),{suspense:!1})),e.withPromise(this.executeQuery(e.createRequest(t,r),n))},_.prototype.mutation=function(t,r,n){return e.withPromise(this.executeMutation(e.createRequest(t,r),n))},exports.CombinedError=e.CombinedError,exports.createRequest=e.createRequest,exports.formatDocument=e.formatDocument,exports.makeErrorResult=e.makeErrorResult,exports.makeResult=e.makeResult,exports.stringifyVariables=e.stringifyVariables,exports.Client=_,exports.cacheExchange=s,exports.composeExchanges=g,exports.createClient=function(e){return new _(e)},exports.debugExchange=function(e){var t=e.forward;return function(e){return t(e)}},exports.dedupExchange=x,exports.defaultExchanges=E,exports.fallbackExchangeIO=b,exports.fetchExchange=m,exports.ssrExchange=function(r){var i={},a=function(e){return!n(e)&&void 0!==i[e.key]};function u(e){return!a(e)}function c(t){var r,n,o;return o={operation:t,data:(r=i[t.key]).data,extensions:void 0,error:void 0},void 0!==(n=r.error)&&(o.error=new e.CombinedError({networkError:new Error(n.networkError),graphQLErrors:n.graphQLErrors})),o}function s(e){return a(e)}function f(e){var t=e.operation;if(!n(t)){var r=function(e){var t=e.error,r={data:e.data,error:void 0};return void 0!==t&&(r.error={networkError:""+t.networkError,graphQLErrors:t.graphQLErrors.map(o)}),r}(e);i[t.key]=r}}function p(e){delete i[e.operation.key]}var l=function(e){var n=e.client,o=e.forward;return function(e){var i=r&&"boolean"==typeof r.isClient?!!r.isClient:!n.suspense,a=t.share(e),l=o(t.filter(u)(a)),d=t.map(c)(t.filter(s)(a));return i?d=t.tap(p)(d):l=t.tap(f)(l),t.merge([l,d])}};return l.restoreData=function(t){return e._extends(i,t)},l.extractData=function(){return e._extends({},i)},r&&r.initialState&&l.restoreData(r.initialState),l},exports.subscriptionExchange=function(n){var o=n.forwardSubscription;return function(n){var i=n.client,a=n.forward;return function(n){var u=t.share(n),c=t.mergeMap(function(n){var a=n.key,c=t.filter(function(e){return"teardown"===e.operationName&&e.key===a})(u);return t.takeUntil(c)(function(n){var a=o({key:n.key.toString(36),query:r.print(n.query),variables:n.variables,context:e._extends({},n.context)});return t.make(function(t){var r=t.next,o=t.complete,u=!1,c=a.subscribe({next:function(t){return r(e.makeResult(n,t))},error:function(t){return r(e.makeErrorResult(n,t))},complete:function(){u||i.reexecuteOperation(e._extends(e._extends({},n),{operationName:"teardown"})),o()}});return function(){u=!0,c.unsubscribe()}})}(n))})(t.filter(d)(u)),s=a(t.filter(h)(u));return t.merge([c,s])}}};
\ No newline at end of file
+"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=require("./index-dddbd19e.js"),t=require("wonka"),r=require("graphql"),n=function(e){var t=e.operationName;return"subscription"!==t&&"query"!==t};function o(e){return""+e}var i=function(e){var t=e.operationName;return"mutation"!==t&&"query"!==t};function a(t){return e._extends(e._extends({},t),{query:e.formatDocument(t.query)})}function u(t){return e.addMetadata(t,{cacheOutcome:"miss"})}function s(e){return i(e)}var c=function(r){var n=r.forward,o=r.client,c=new Map,d=Object.create(null),h=a,v=p(c,d,o),x=l(c,d),m=function(e){var t=e.context.requestPolicy;return"query"===e.operationName&&"network-only"!==t&&("cache-only"===t||c.has(e.key))};function y(t){var r=c.get(t.key),n=e._extends(e._extends({},r),{operation:e.addMetadata(t,{cacheOutcome:r?"hit":"miss"})});return"cache-and-network"===t.context.requestPolicy&&(n.stale=!0,f(o,t)),n}function k(e){return!i(e)&&m(e)}function O(e){e.operation&&"mutation"===e.operation.operationName?v(e):e.operation&&"query"===e.operation.operationName&&x(e)}function q(e){return!i(e)&&!m(e)}return function(e){var r=t.share(e),o=t.map(y)(t.filter(k)(r)),i=t.tap(O)(n(t.map(u)(t.merge([t.map(h)(t.filter(q)(r)),t.filter(s)(r)]))));return t.merge([o,i])}},f=function(t,r){return t.reexecuteOperation(e._extends(e._extends({},r),{context:e._extends(e._extends({},r.context),{requestPolicy:"network-only"})}))},p=function(t,r,n){function o(e){if(t.has(e)){var r=t.get(e).operation;t.delete(e),f(n,r)}}return function(t){var n=new Set;function i(e){n.add(e)}e.collectTypesFromResponse(t.data).forEach(function(e){var t=r[e]||(r[e]=new Set);t.forEach(i),t.clear()}),n.forEach(o)}},l=function(t,r){return function(n){var o=n.operation,i=n.data;null!=i&&(t.set(o.key,{operation:o,data:i,error:n.error}),e.collectTypesFromResponse(n.data).forEach(function(e){(r[e]||(r[e]=new Set)).add(o.key)}))}},d=function(e){return"subscription"===e.operationName};function h(e){return!d(e)}var v=function(e){var r=e.forward,n=new Set,o=function(e){var t=e.key,r=e.operationName;if("teardown"===r)return n.delete(t),!0;if("query"!==r&&"subscription"!==r)return!0;var o=n.has(t);return n.add(t),!o},i=function(e){n.delete(e.operation.key)};return function(e){var n=t.filter(o)(e);return t.tap(i)(r(n))}};function x(e){var t=e.operationName;return"query"===t||"mutation"===t}var m=function(e){var r=e.forward,n=x;function o(e){return!n(e)}return function(e){var i=t.share(e),a=t.mergeMap(function(e){var r=e.key,n=t.filter(function(e){return"teardown"===e.operationName&&e.key===r})(i);return t.takeUntil(n)(k(e))})(t.filter(n)(i)),u=r(t.filter(o)(i));return t.merge([a,u])}};function y(e){return e.kind===r.Kind.OPERATION_DEFINITION&&e.name}var k=function(n){return t.make(function(t){var o,i=t.next,a=t.complete,u="undefined"!=typeof AbortController?new AbortController:void 0,s=n.context,c="function"==typeof s.fetchOptions?s.fetchOptions():s.fetchOptions||{},f=void 0!==(o=n.query.definitions.find(y))&&o.name?o.name.value:null,p={query:r.print(n.query),variables:n.variables};null!==f&&(p.operationName=f);var l=e._extends(e._extends({body:JSON.stringify(p),method:"POST"},c),{headers:e._extends({"content-type":"application/json"},c.headers),signal:void 0!==u?u.signal:void 0}),d=!1;return Promise.resolve().then(function(){return d?void 0:O(n,l)}).then(function(e){d||(d=!0,e&&i(e),a())}),function(){d=!0,void 0!==u&&u.abort()}})},O=function(t,r){var n,o=t.context;return(o.fetch||fetch)(o.url,r).then(function(e){var t=e.status;if(n=e,t<200||t>=("manual"===r.redirect?400:300))throw new Error(e.statusText);return e.json()}).then(function(r){return e.makeResult(t,r,n)}).catch(function(r){if("AbortError"!==r.name)return e.makeErrorResult(t,r,n)})};function q(){return!1}function w(e){}var b=function(e){return t.filter(q)(t.tap(w)(e))},g=function(e){return 1===e.length?e[0]:function(t){return e.reduceRight(function(e,r){return r({client:t.client,forward:e})},t.forward)}},E=[v,c,m],_=function(r){var n=this;this.activeOperations=Object.create(null),this.createOperationContext=function(t){return e._extends(e._extends({url:n.url,fetchOptions:n.fetchOptions,fetch:n.fetch},t),{requestPolicy:(t||{}).requestPolicy||n.requestPolicy})},this.createRequestOperation=function(e,t,r){return{key:t.key,query:t.query,variables:t.variables,operationName:e,context:n.createOperationContext(r)}},this.reexecuteOperation=function(e){(n.activeOperations[e.key]||0)>0&&n.dispatchOperation(e)},this.executeQuery=function(e,r){var o=n.createRequestOperation("query",e,r),i=n.executeRequestOperation(o),a=o.context.pollInterval;return a?t.switchMap(function(){return i})(t.merge([t.fromValue(0),t.interval(a)])):i},this.executeSubscription=function(e,t){var r=n.createRequestOperation("subscription",e,t);return n.executeRequestOperation(r)},this.executeMutation=function(e,t){var r=n.createRequestOperation("mutation",e,t);return n.executeRequestOperation(r)},this.url=r.url,this.fetchOptions=r.fetchOptions,this.fetch=r.fetch,this.suspense=!!r.suspense,this.requestPolicy=r.requestPolicy||"cache-first";var o=t.makeSubject(),i=o.next;this.operations$=o.source;var a=[],u=!1;this.dispatchOperation=function(e){if(a.push(e),!u){var t;for(u=!0;void 0!==(t=a.shift());)i(t);u=!1}},this.exchange=g(void 0!==r.exchanges?r.exchanges:E),this.results$=t.share(this.exchange({client:this,forward:b})(this.operations$)),t.publish(this.results$)};_.prototype.onOperationStart=function(e){var t=e.key;this.activeOperations[t]=(this.activeOperations[t]||0)+1,this.dispatchOperation(e)},_.prototype.onOperationEnd=function(t){var r=t.key,n=this.activeOperations[r]||0;(this.activeOperations[r]=n<=0?0:n-1)<=0&&this.dispatchOperation(e._extends(e._extends({},t),{operationName:"teardown"}))},_.prototype.executeRequestOperation=function(r){var n=this,o=r.key,i=r.operationName,a=t.filter(function(e){return e.operation.key===o})(this.results$);if("mutation"===i)return t.take(1)(t.onStart(function(){return n.dispatchOperation(r)})(a));var u=t.filter(function(e){return"teardown"===e.operationName&&e.key===o})(this.operations$),s=t.onEnd(function(){n.onOperationEnd(r)})(t.onStart(function(){n.onOperationStart(r)})(t.takeUntil(u)(a)));return!1!==r.context.suspense&&this.suspense&&"query"===i?e.toSuspenseSource(s):s},_.prototype.query=function(t,r,n){return n&&"boolean"==typeof n.suspense||(n=e._extends(e._extends({},n),{suspense:!1})),e.withPromise(this.executeQuery(e.createRequest(t,r),n))},_.prototype.mutation=function(t,r,n){return e.withPromise(this.executeMutation(e.createRequest(t,r),n))},exports.CombinedError=e.CombinedError,exports.createRequest=e.createRequest,exports.formatDocument=e.formatDocument,exports.makeErrorResult=e.makeErrorResult,exports.makeResult=e.makeResult,exports.stringifyVariables=e.stringifyVariables,exports.Client=_,exports.cacheExchange=c,exports.composeExchanges=g,exports.createClient=function(e){return new _(e)},exports.debugExchange=function(e){var t=e.forward;return function(e){return t(e)}},exports.dedupExchange=v,exports.defaultExchanges=E,exports.fallbackExchangeIO=b,exports.fetchExchange=m,exports.ssrExchange=function(r){var i={},a=function(e){return!n(e)&&void 0!==i[e.key]};function u(e){return!a(e)}function s(t){var r,n,o;return o={operation:t,data:(r=i[t.key]).data,extensions:void 0,error:void 0},void 0!==(n=r.error)&&(o.error=new e.CombinedError({networkError:new Error(n.networkError),graphQLErrors:n.graphQLErrors})),o}function c(e){return a(e)}function f(e){var t=e.operation;if(!n(t)){var r=function(e){var t=e.error,r={data:e.data,error:void 0};return void 0!==t&&(r.error={networkError:""+t.networkError,graphQLErrors:t.graphQLErrors.map(o)}),r}(e);i[t.key]=r}}function p(e){delete i[e.operation.key]}var l=function(e){var n=e.client,o=e.forward;return function(e){var i=r&&"boolean"==typeof r.isClient?!!r.isClient:!n.suspense,a=t.share(e),l=o(t.filter(u)(a)),d=t.map(s)(t.filter(c)(a));return i?d=t.tap(p)(d):l=t.tap(f)(l),t.merge([l,d])}};return l.restoreData=function(t){return e._extends(i,t)},l.extractData=function(){return e._extends({},i)},r&&r.initialState&&l.restoreData(r.initialState),l},exports.subscriptionExchange=function(n){var o=n.forwardSubscription;return function(n){var i=n.client,a=n.forward;return function(n){var u=t.share(n),s=t.mergeMap(function(n){var a=n.key,s=t.filter(function(e){return"teardown"===e.operationName&&e.key===a})(u);return t.takeUntil(s)(function(n){var a=o({key:n.key.toString(36),query:r.print(n.query),variables:n.variables,context:e._extends({},n.context)});return t.make(function(t){var r=t.next,o=t.complete,u=!1,s=a.subscribe({next:function(t){return r(e.makeResult(n,t))},error:function(t){return r(e.makeErrorResult(n,t))},complete:function(){u||(u=!0,i.reexecuteOperation(e._extends(e._extends({},n),{operationName:"teardown"})),o())}});return function(){u=!0,s.unsubscribe()}})}(n))})(t.filter(d)(u)),c=a(t.filter(h)(u));return t.merge([s,c])}}};
\ No newline at end of file
diff --git a/node_modules/urql/dist/cjs/min/urql.js b/node_modules/urql/dist/cjs/min/urql.js
index d5b5bd8..fd44313 100644
--- a/node_modules/urql/dist/cjs/min/urql.js
+++ b/node_modules/urql/dist/cjs/min/urql.js
@@ -1 +1 @@
-"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=require("./index-dddbd19e.js"),t=require("wonka");var r=require("./core.js"),n=require("react"),a=require("react-wonka"),u=r.createClient({url:"/graphql"}),s=n.createContext(u),o=s.Provider,c=s.Consumer,i=function(){return n.useContext(s)},x={fetching:!1,stale:!1,error:void 0,data:void 0,extensions:void 0},l=function(r){var a=i(),u=n.useState(x),s=u[1];function o(e){return s({fetching:!1,stale:!!e.stale,data:e.data,error:e.error,extensions:e.extensions}),e}return[u[0],n.useCallback(function(n,u){s(e._extends(e._extends({},x),{fetching:!0}));var c=e.createRequest(r,n);return t.toPromise(a.executeMutation(c,u||{})).then(o)},[a,r,s])]},d=function(t,r){var a=n.useRef(void 0);return n.useMemo(function(){var n=e.createRequest(t,r);return void 0!==a.current&&a.current.key===n.key?a.current:(a.current=n,n)},[t,r])};function f(t,r){return e._extends(e._extends(e._extends({},t),{stale:!1}),r)}function p(e){return{fetching:!1,stale:!!e.stale,data:e.data,error:e.error,extensions:e.extensions}}function h(e){return e?t.concat([t.fromValue({fetching:!0}),t.map(p)(e),t.fromValue({fetching:!1})]):t.fromValue({fetching:!1})}function g(e){return t.scan(f,x)(t.switchMap(h)(e))}var v=function(t){var r=i(),u=d(t.query,t.variables),s=n.useCallback(function(n){return r.executeQuery(u,e._extends(e._extends({requestPolicy:t.requestPolicy,pollInterval:t.pollInterval},t.context),n))},[r,u,t.requestPolicy,t.pollInterval,t.context]),o=a.useOperator(g,n.useMemo(function(){return t.pause?null:s()},[t.pause,s]),x),c=o[1];return[o[0],n.useCallback(function(e){return c(s(e))},[c,s])]};function m(e){return{fetching:!0,stale:!!e.stale,data:e.data,error:e.error,extensions:e.extensions}}function b(e){return e?t.concat([t.fromValue({fetching:!0}),t.map(m)(e),t.fromValue({fetching:!1})]):t.fromValue({fetching:!1})}var E=function(r,u){var s=i(),o=n.useRef(u);o.current=u;var c=d(r.query,r.variables),l=n.useCallback(function(t){return s.executeSubscription(c,e._extends(e._extends({},r.context),t))},[s,c,r.context]);function f(t,r){var n=o.current,a=void 0!==r.data?"function"==typeof n?n(t.data,r.data):r.data:t.data;return e._extends(e._extends(e._extends(e._extends({},t),{stale:!1}),r),{data:a})}var p=a.useOperator(function(e){return t.scan(f,x)(t.switchMap(b)(e))},n.useMemo(function(){return r.pause?null:l()},[r.pause,l]),x),h=p[1];return[p[0],n.useCallback(function(e){return h(l(e))},[h,l])]};exports.CombinedError=e.CombinedError,exports.createRequest=e.createRequest,exports.formatDocument=e.formatDocument,exports.makeErrorResult=e.makeErrorResult,exports.makeResult=e.makeResult,exports.stringifyVariables=e.stringifyVariables,exports.Client=r.Client,exports.cacheExchange=r.cacheExchange,exports.composeExchanges=r.composeExchanges,exports.createClient=r.createClient,exports.debugExchange=r.debugExchange,exports.dedupExchange=r.dedupExchange,exports.defaultExchanges=r.defaultExchanges,exports.fallbackExchangeIO=r.fallbackExchangeIO,exports.fetchExchange=r.fetchExchange,exports.ssrExchange=r.ssrExchange,exports.subscriptionExchange=r.subscriptionExchange,exports.Consumer=c,exports.Context=s,exports.Mutation=function(t){var r=l(t.query),n=r[1];return t.children(e._extends(e._extends({},r[0]),{executeMutation:n}))},exports.Provider=o,exports.Query=function(t){var r=v(t),n=r[1];return t.children(e._extends(e._extends({},r[0]),{executeQuery:n}))},exports.Subscription=function(t){var r=E(t,t.handler),n=r[1];return t.children(e._extends(e._extends({},r[0]),{executeSubscription:n}))},exports.useClient=i,exports.useMutation=l,exports.useQuery=v,exports.useSubscription=E;
\ No newline at end of file
+"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=require("./index-dddbd19e.js"),t=require("wonka");var r=require("./core.js"),n=require("react"),u=require("use-subscription"),s=r.createClient({url:"/graphql"}),o=n.createContext(s),a=o.Provider,c=o.Consumer,i=function(){return n.useContext(o)},x={fetching:!1,stale:!1,error:void 0,data:void 0,extensions:void 0},l=function(r){var u=i(),s=n.useState(x),o=s[1];function a(e){return o({fetching:!1,stale:!!e.stale,data:e.data,error:e.error,extensions:e.extensions}),e}return[s[0],n.useCallback(function(n,s){o(e._extends(e._extends({},x),{fetching:!0}));var c=e.createRequest(r,n);return t.toPromise(u.executeMutation(c,s||{})).then(a)},[u,r,o])]},f=function(e,r){return u.useSubscription(n.useMemo(function(){var n=!1,u=r,s=t.onPush(function(e){u=e})(e);return{getCurrentValue:function(){return n||t.publish(s).unsubscribe(),u},subscribe:function(e){return t.subscribe(function(){n=!0,e(),n=!1})(s).unsubscribe}}},[e]))},d=function(e){var r=n.useMemo(function(){var r=e,n=t.makeSubject(),u=t.map(function(){return r})(t.fromValue(e));return[t.concat([u,n.source]),function(e){n.next(r=e)}]},[]);return n.useEffect(function(){r[1](e)},[r,e]),r},p=function(t,r){var u=n.useRef(void 0);return n.useMemo(function(){var n=e.createRequest(t,r);return void 0!==u.current&&u.current.key===n.key?u.current:(u.current=n,n)},[t,r])};function h(t,r){return e._extends(e._extends({},t),r)}function g(e){return{fetching:!1,stale:!!e.stale,data:e.data,error:e.error,extensions:e.extensions}}function b(e){return e?t.concat([t.fromValue({fetching:!0,stale:!1}),t.map(g)(e),t.fromValue({fetching:!1,stale:!1})]):t.fromValue({fetching:!1,stale:!1})}var m=function(r){var u=i(),s=p(r.query,r.variables),o=n.useCallback(function(t){return u.executeQuery(s,e._extends(e._extends({requestPolicy:r.requestPolicy,pollInterval:r.pollInterval},r.context),t))},[u,s,r.requestPolicy,r.pollInterval,r.context]),a=d(n.useMemo(function(){return r.pause?null:o()},[r.pause,o])),c=a[0],l=a[1];return[f(n.useMemo(function(){return t.scan(h,x)(t.switchMap(b)(c))},[c]),x),n.useCallback(function(e){return l(o(e))},[l,o])]};function v(e){return{fetching:!0,stale:!!e.stale,data:e.data,error:e.error,extensions:e.extensions}}function E(e){return e?t.concat([t.fromValue({fetching:!0,stale:!1}),t.map(v)(e),t.fromValue({fetching:!1,stale:!1})]):t.fromValue({fetching:!1})}var C=function(r,u){var s=i(),o=n.useRef(u);o.current=u;var a=p(r.query,r.variables),c=n.useCallback(function(t){return s.executeSubscription(a,e._extends(e._extends({},r.context),t))},[s,a,r.context]),l=d(n.useMemo(function(){return r.pause?null:c()},[r.pause,c])),h=l[0],g=l[1];function b(t,r){var n=o.current,u=void 0!==r.data?"function"==typeof n?n(t.data,r.data):r.data:t.data;return e._extends(e._extends(e._extends({},t),r),{data:u})}return[f(n.useMemo(function(){return t.scan(b,x)(t.switchMap(E)(h))},[h]),x),n.useCallback(function(e){return g(c(e))},[g,c])]};exports.CombinedError=e.CombinedError,exports.createRequest=e.createRequest,exports.formatDocument=e.formatDocument,exports.makeErrorResult=e.makeErrorResult,exports.makeResult=e.makeResult,exports.stringifyVariables=e.stringifyVariables,exports.Client=r.Client,exports.cacheExchange=r.cacheExchange,exports.composeExchanges=r.composeExchanges,exports.createClient=r.createClient,exports.debugExchange=r.debugExchange,exports.dedupExchange=r.dedupExchange,exports.defaultExchanges=r.defaultExchanges,exports.fallbackExchangeIO=r.fallbackExchangeIO,exports.fetchExchange=r.fetchExchange,exports.ssrExchange=r.ssrExchange,exports.subscriptionExchange=r.subscriptionExchange,exports.Consumer=c,exports.Context=o,exports.Mutation=function(t){var r=l(t.query),n=r[1];return t.children(e._extends(e._extends({},r[0]),{executeMutation:n}))},exports.Provider=a,exports.Query=function(t){var r=m(t),n=r[1];return t.children(e._extends(e._extends({},r[0]),{executeQuery:n}))},exports.Subscription=function(t){var r=C(t,t.handler),n=r[1];return t.children(e._extends(e._extends({},r[0]),{executeSubscription:n}))},exports.useClient=i,exports.useMutation=l,exports.useQuery=m,exports.useSubscription=C;
\ No newline at end of file
diff --git a/node_modules/urql/dist/cjs/urql.js b/node_modules/urql/dist/cjs/urql.js
index 0b9bdac..fc368c3 100644
--- a/node_modules/urql/dist/cjs/urql.js
+++ b/node_modules/urql/dist/cjs/urql.js
@@ -8,7 +8,7 @@ var core = require("./core.js");
 
 var react = require("react");
 
-var reactWonka = require("react-wonka");
+var useSubscription$1 = require("use-subscription");
 
 var defaultClient = core.createClient({
   url: "/graphql"
@@ -62,6 +62,49 @@ var useMutation = function (query) {
   }, [client, query, setState])];
 };
 
+var useSource = function (source, init) {
+  return useSubscription$1.useSubscription(react.useMemo(function () {
+    var hasUpdate = !1;
+    var currentValue = init;
+    var updateValue = wonka.onPush(function (value) {
+      currentValue = value;
+    })(source);
+    return {
+      getCurrentValue: function getCurrentValue() {
+        if (!hasUpdate) {
+          wonka.publish(updateValue).unsubscribe();
+        }
+
+        return currentValue;
+      },
+      subscribe: function subscribe$1(onValue) {
+        return wonka.subscribe(function () {
+          hasUpdate = !0;
+          onValue();
+          hasUpdate = !1;
+        })(updateValue).unsubscribe;
+      }
+    };
+  }, [source]));
+};
+
+var useBehaviourSubject = function (value) {
+  var state = react.useMemo(function () {
+    var prevValue = value;
+    var subject = wonka.makeSubject();
+    var prevValue$ = wonka.map(function () {
+      return prevValue;
+    })(wonka.fromValue(value));
+    return [wonka.concat([prevValue$, subject.source]), function (value) {
+      subject.next(prevValue = value);
+    }];
+  }, []);
+  react.useEffect(function () {
+    state[1](value);
+  }, [state, value]);
+  return state;
+};
+
 var useRequest = function (query, variables) {
   var prev = react.useRef(void 0);
   return react.useMemo(function () {
@@ -77,9 +120,7 @@ var useRequest = function (query, variables) {
 };
 
 function _ref(result, partial) {
-  return index._extends(index._extends(index._extends({}, result), {
-    stale: !1
-  }), partial);
+  return index._extends(index._extends({}, result), partial);
 }
 
 function _ref2(ref) {
@@ -95,21 +136,20 @@ function _ref2(ref) {
 function _ref3(query$) {
   if (!query$) {
     return wonka.fromValue({
-      fetching: !1
+      fetching: !1,
+      stale: !1
     });
   }
 
   return wonka.concat([wonka.fromValue({
-    fetching: !0
+    fetching: !0,
+    stale: !1
   }), wonka.map(_ref2)(query$), wonka.fromValue({
-    fetching: !1
+    fetching: !1,
+    stale: !1
   })]);
 }
 
-function _ref4(query$$) {
-  return wonka.scan(_ref, initialState)(wonka.switchMap(_ref3)(query$$));
-}
-
 var useQuery = function (args) {
   var client = useClient();
   var request = useRequest(args.query, args.variables);
@@ -119,11 +159,14 @@ var useQuery = function (args) {
       pollInterval: args.pollInterval
     }, args.context), opts));
   }, [client, request, args.requestPolicy, args.pollInterval, args.context]);
-  var ref = reactWonka.useOperator(_ref4, react.useMemo(function () {
+  var ref = useBehaviourSubject(react.useMemo(function () {
     return args.pause ? null : makeQuery$();
-  }, [args.pause, makeQuery$]), initialState);
+  }, [args.pause, makeQuery$]));
+  var query$$ = ref[0];
   var update = ref[1];
-  return [ref[0], react.useCallback(function (opts) {
+  return [useSource(react.useMemo(function () {
+    return wonka.scan(_ref, initialState)(wonka.switchMap(_ref3)(query$$));
+  }, [query$$]), initialState), react.useCallback(function (opts) {
     return update(makeQuery$(opts));
   }, [update, makeQuery$])];
 };
@@ -146,9 +189,11 @@ function _ref3$1(subscription$) {
   }
 
   return wonka.concat([wonka.fromValue({
-    fetching: !0
+    fetching: !0,
+    stale: !1
   }), wonka.map(_ref2$1)(subscription$), wonka.fromValue({
-    fetching: !1
+    fetching: !1,
+    stale: !1
   })]);
 }
 
@@ -160,24 +205,23 @@ var useSubscription = function (args, handler) {
   var makeSubscription$ = react.useCallback(function (opts) {
     return client.executeSubscription(request, index._extends(index._extends({}, args.context), opts));
   }, [client, request, args.context]);
+  var ref = useBehaviourSubject(react.useMemo(function () {
+    return args.pause ? null : makeSubscription$();
+  }, [args.pause, makeSubscription$]));
+  var subscription$$ = ref[0];
+  var update = ref[1];
 
   function _ref(result, partial) {
     var handler = handlerRef.current;
     var data = void 0 !== partial.data ? "function" == typeof handler ? handler(result.data, partial.data) : partial.data : result.data;
-    return index._extends(index._extends(index._extends(index._extends({}, result), {
-      stale: !1
-    }), partial), {
+    return index._extends(index._extends(index._extends({}, result), partial), {
       data: data
     });
   }
 
-  var ref = reactWonka.useOperator(function (subscription$$) {
+  return [useSource(react.useMemo(function () {
     return wonka.scan(_ref, initialState)(wonka.switchMap(_ref3$1)(subscription$$));
-  }, react.useMemo(function () {
-    return args.pause ? null : makeSubscription$();
-  }, [args.pause, makeSubscription$]), initialState);
-  var update = ref[1];
-  return [ref[0], react.useCallback(function (opts) {
+  }, [subscription$$]), initialState), react.useCallback(function (opts) {
     return update(makeSubscription$(opts));
   }, [update, makeSubscription$])];
 };
diff --git a/node_modules/urql/dist/cjs/urql.js.map b/node_modules/urql/dist/cjs/urql.js.map
index bb9aaff..a5c7f34 100644
--- a/node_modules/urql/dist/cjs/urql.js.map
+++ b/node_modules/urql/dist/cjs/urql.js.map
@@ -1 +1 @@
-{"version":3,"file":"urql.js","sources":["../../src/context.ts","../../src/hooks/constants.ts","../../src/hooks/useMutation.ts","../../src/hooks/useRequest.ts","../../src/hooks/useQuery.ts","../../src/hooks/useSubscription.ts","../../src/components/Mutation.ts","../../src/components/Query.ts","../../src/components/Subscription.ts"],"sourcesContent":["import { createContext, useContext } from 'react';\nimport { Client, createClient } from './client';\n\n// We assume some default options here; mainly not to actually be used\n// but not to error catastrophically if someone is just playing around\nconst defaultClient = createClient({ url: '/graphql' });\n\nexport const Context = createContext<Client>(defaultClient);\nexport const Provider = Context.Provider;\nexport const Consumer = Context.Consumer;\n\nlet hasWarnedAboutDefault = false;\n\nexport const useClient = (): Client => {\n  const client = useContext(Context);\n\n  if (\n    process.env.NODE_ENV !== 'production' &&\n    client === defaultClient &&\n    !hasWarnedAboutDefault\n  ) {\n    hasWarnedAboutDefault = true;\n\n    console.warn(\n      \"Default Client: No client has been specified using urql's Provider.\" +\n        'This means that urql will be falling back to defaults including making ' +\n        'requests to `/graphql`.\\n' +\n        \"If that's not what you want, please create a client and add a Provider.\"\n    );\n  }\n\n  return client;\n};\n","export const initialState = {\n  fetching: false,\n  stale: false,\n  error: undefined,\n  data: undefined,\n  extensions: undefined,\n};\n","import { DocumentNode } from 'graphql';\nimport { useState, useCallback } from 'react';\nimport { pipe, toPromise } from 'wonka';\nimport { useClient } from '../context';\nimport { OperationResult, OperationContext } from '../types';\nimport { CombinedError, createRequest } from '../utils';\nimport { initialState } from './constants';\n\nexport interface UseMutationState<T> {\n  fetching: boolean;\n  stale: boolean;\n  data?: T;\n  error?: CombinedError;\n  extensions?: Record<string, any>;\n}\n\nexport type UseMutationResponse<T, V> = [\n  UseMutationState<T>,\n  (\n    variables?: V,\n    context?: Partial<OperationContext>\n  ) => Promise<OperationResult<T>>\n];\n\nexport const useMutation = <T = any, V = object>(\n  query: DocumentNode | string\n): UseMutationResponse<T, V> => {\n  const client = useClient();\n\n  const [state, setState] = useState<UseMutationState<T>>(initialState);\n\n  const executeMutation = useCallback(\n    (variables?: V, context?: Partial<OperationContext>) => {\n      setState({ ...initialState, fetching: true });\n\n      const request = createRequest(query, variables as any);\n\n      return pipe(\n        client.executeMutation(request, context || {}),\n        toPromise\n      ).then(result => {\n        setState({\n          fetching: false,\n          stale: !!result.stale,\n          data: result.data,\n          error: result.error,\n          extensions: result.extensions,\n        });\n        return result;\n      });\n    },\n    [client, query, setState]\n  );\n\n  return [state, executeMutation];\n};\n","import { DocumentNode } from 'graphql';\nimport { useRef, useMemo } from 'react';\nimport { GraphQLRequest } from '../types';\nimport { createRequest } from '../utils';\n\n/** Creates a request from a query and variables but preserves reference equality if the key isn't changing */\nexport const useRequest = (\n  query: string | DocumentNode,\n  variables?: any\n): GraphQLRequest => {\n  const prev = useRef<undefined | GraphQLRequest>(undefined);\n\n  return useMemo(() => {\n    const request = createRequest(query, variables);\n    // We manually ensure reference equality if the key hasn't changed\n    if (prev.current !== undefined && prev.current.key === request.key) {\n      return prev.current;\n    } else {\n      prev.current = request;\n      return request;\n    }\n  }, [query, variables]);\n};\n","import { DocumentNode } from 'graphql';\nimport { useCallback, useMemo } from 'react';\nimport { pipe, concat, fromValue, switchMap, map, scan } from 'wonka';\nimport { useOperator } from 'react-wonka';\n\nimport { useClient } from '../context';\nimport { OperationContext, RequestPolicy } from '../types';\nimport { CombinedError } from '../utils';\nimport { useRequest } from './useRequest';\nimport { initialState } from './constants';\n\nexport interface UseQueryArgs<V> {\n  query: string | DocumentNode;\n  variables?: V;\n  requestPolicy?: RequestPolicy;\n  pollInterval?: number;\n  context?: Partial<OperationContext>;\n  pause?: boolean;\n}\n\nexport interface UseQueryState<T> {\n  fetching: boolean;\n  stale: boolean;\n  data?: T;\n  error?: CombinedError;\n  extensions?: Record<string, any>;\n}\n\nexport type UseQueryResponse<T> = [\n  UseQueryState<T>,\n  (opts?: Partial<OperationContext>) => void\n];\n\nexport const useQuery = <T = any, V = object>(\n  args: UseQueryArgs<V>\n): UseQueryResponse<T> => {\n  const client = useClient();\n\n  // This creates a request which will keep a stable reference\n  // if request.key doesn't change\n  const request = useRequest(args.query, args.variables);\n\n  // Create a new query-source from client.executeQuery\n  const makeQuery$ = useCallback(\n    (opts?: Partial<OperationContext>) => {\n      return client.executeQuery(request, {\n        requestPolicy: args.requestPolicy,\n        pollInterval: args.pollInterval,\n        ...args.context,\n        ...opts,\n      });\n    },\n    [client, request, args.requestPolicy, args.pollInterval, args.context]\n  );\n\n  const [state, update] = useOperator(\n    query$$ =>\n      pipe(\n        query$$,\n        switchMap(query$ => {\n          if (!query$) return fromValue({ fetching: false });\n\n          return concat([\n            // Initially set fetching to true\n            fromValue({ fetching: true }),\n            pipe(\n              query$,\n              map(({ stale, data, error, extensions }) => ({\n                fetching: false,\n                stale: !!stale,\n                data,\n                error,\n                extensions,\n              }))\n            ),\n            // When the source proactively closes, fetching is set to false\n            fromValue({ fetching: false }),\n          ]);\n        }),\n        // The individual partial results are merged into each previous result\n        scan(\n          (result, partial: { fetching: boolean }) => ({\n            ...result,\n            stale: false,\n            ...partial,\n          }),\n          initialState\n        )\n      ),\n    useMemo(() => (args.pause ? null : makeQuery$()), [args.pause, makeQuery$]),\n    initialState\n  );\n\n  // This is the imperative execute function passed to the user\n  const executeQuery = useCallback(\n    (opts?: Partial<OperationContext>) => update(makeQuery$(opts)),\n    [update, makeQuery$]\n  );\n\n  return [state, executeQuery];\n};\n","import { DocumentNode } from 'graphql';\nimport { useCallback, useRef, useMemo } from 'react';\nimport { pipe, concat, fromValue, switchMap, map, scan } from 'wonka';\nimport { useOperator } from 'react-wonka';\n\nimport { useClient } from '../context';\nimport { CombinedError } from '../utils';\nimport { OperationContext } from '../types';\nimport { useRequest } from './useRequest';\nimport { initialState } from './constants';\n\nexport interface UseSubscriptionArgs<V> {\n  query: DocumentNode | string;\n  variables?: V;\n  pause?: boolean;\n  context?: Partial<OperationContext>;\n}\n\nexport type SubscriptionHandler<T, R> = (prev: R | undefined, data: T) => R;\n\nexport interface UseSubscriptionState<T> {\n  fetching: boolean;\n  stale: boolean;\n  data?: T;\n  error?: CombinedError;\n  extensions?: Record<string, any>;\n}\n\nexport type UseSubscriptionResponse<T> = [\n  UseSubscriptionState<T>,\n  (opts?: Partial<OperationContext>) => void\n];\n\nexport const useSubscription = <T = any, R = T, V = object>(\n  args: UseSubscriptionArgs<V>,\n  handler?: SubscriptionHandler<T, R>\n): UseSubscriptionResponse<R> => {\n  const client = useClient();\n\n  // Update handler on constant ref, since handler changes shouldn't\n  // trigger a new subscription run\n  const handlerRef = useRef(handler);\n  handlerRef.current = handler;\n\n  // This creates a request which will keep a stable reference\n  // if request.key doesn't change\n  const request = useRequest(args.query, args.variables);\n\n  // Create a new subscription-source from client.executeSubscription\n  const makeSubscription$ = useCallback(\n    (opts?: Partial<OperationContext>) => {\n      return client.executeSubscription(request, { ...args.context, ...opts });\n    },\n    [client, request, args.context]\n  );\n\n  const [state, update] = useOperator(\n    subscription$$ =>\n      pipe(\n        subscription$$,\n        switchMap(subscription$ => {\n          if (!subscription$) return fromValue({ fetching: false });\n\n          return concat([\n            // Initially set fetching to true\n            fromValue({ fetching: true }),\n            pipe(\n              subscription$,\n              map(({ stale, data, error, extensions }) => ({\n                fetching: true,\n                stale: !!stale,\n                data,\n                error,\n                extensions,\n              }))\n            ),\n            // When the source proactively closes, fetching is set to false\n            fromValue({ fetching: false }),\n          ]);\n        }),\n        // The individual partial results are merged into each previous result\n        scan((result, partial: any) => {\n          const { current: handler } = handlerRef;\n          // If a handler has been passed, it's used to merge new data in\n          const data =\n            partial.data !== undefined\n              ? typeof handler === 'function'\n                ? handler(result.data, partial.data)\n                : partial.data\n              : result.data;\n          return { ...result, stale: false, ...partial, data };\n        }, initialState)\n      ),\n    useMemo(() => (args.pause ? null : makeSubscription$()), [\n      args.pause,\n      makeSubscription$,\n    ]),\n    initialState\n  );\n\n  // This is the imperative execute function passed to the user\n  const executeSubscription = useCallback(\n    (opts?: Partial<OperationContext>) => update(makeSubscription$(opts)),\n    [update, makeSubscription$]\n  );\n\n  return [state, executeSubscription];\n};\n","import { ReactElement } from 'react';\nimport { DocumentNode } from 'graphql';\nimport { OperationResult, OperationContext } from '../types';\nimport { useMutation, UseMutationState } from '../hooks';\n\nexport interface MutationProps<T, V> {\n  query: DocumentNode | string;\n  children: (arg: MutationState<T, V>) => ReactElement<any>;\n}\n\nexport interface MutationState<T, V> extends UseMutationState<T> {\n  executeMutation: (\n    variables?: V,\n    context?: Partial<OperationContext>\n  ) => Promise<OperationResult<T>>;\n}\n\nexport function Mutation<T = any, V = any>(\n  props: MutationProps<T, V>\n): ReactElement<any> {\n  const [state, executeMutation] = useMutation<T, V>(props.query);\n  return props.children({ ...state, executeMutation });\n}\n","import { ReactElement } from 'react';\nimport { OperationContext } from '../types';\nimport { useQuery, UseQueryArgs, UseQueryState } from '../hooks';\n\nexport interface QueryProps<T, V> extends UseQueryArgs<V> {\n  children: (arg: QueryState<T>) => ReactElement<any>;\n}\n\nexport interface QueryState<T> extends UseQueryState<T> {\n  executeQuery: (opts?: Partial<OperationContext>) => void;\n}\n\nexport function Query<T = any, V = any>(\n  props: QueryProps<T, V>\n): ReactElement<any> {\n  const [state, executeQuery] = useQuery<T, V>(props);\n  return props.children({ ...state, executeQuery });\n}\n","import { ReactElement } from 'react';\nimport { OperationContext } from '../types';\n\nimport {\n  useSubscription,\n  UseSubscriptionArgs,\n  UseSubscriptionState,\n  SubscriptionHandler,\n} from '../hooks';\n\nexport interface SubscriptionProps<T, R, V> extends UseSubscriptionArgs<V> {\n  handler?: SubscriptionHandler<T, R>;\n  children: (arg: SubscriptionState<R>) => ReactElement<any>;\n}\n\nexport interface SubscriptionState<T> extends UseSubscriptionState<T> {\n  executeSubscription: (opts?: Partial<OperationContext>) => void;\n}\n\nexport function Subscription<T = any, R = T, V = any>(\n  props: SubscriptionProps<T, R, V>\n): ReactElement<any> {\n  const [state, executeSubscription] = useSubscription<T, R, V>(\n    props,\n    props.handler\n  );\n  return props.children({ ...state, executeSubscription });\n}\n"],"names":["const","defaultClient","createClient","url","Context","createContext","Provider","Consumer","let","hasWarnedAboutDefault","useClient","client","useContext","process","env","NODE_ENV","console","warn","initialState","fetching","stale","error","undefined","data","extensions","useMutation","query","useState","result","setState","useCallback","variables","context","request","createRequest","toPromise","executeMutation","then","useRequest","prev","useRef","useMemo","current","key","partial","query$","fromValue","concat","map","query$$","scan","switchMap","useQuery","args","makeQuery$","opts","executeQuery","requestPolicy","pollInterval","useOperator","pause","update","subscription$","useSubscription","handler","handlerRef","makeSubscription$","executeSubscription","subscription$$","Mutation","props","children","Query","Subscription"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"urql.js","sources":["../../src/context.ts","../../src/hooks/constants.ts","../../src/hooks/useMutation.ts","../../src/hooks/useSource.ts","../../src/hooks/useRequest.ts","../../src/hooks/useQuery.ts","../../src/hooks/useSubscription.ts","../../src/components/Mutation.ts","../../src/components/Query.ts","../../src/components/Subscription.ts"],"sourcesContent":["import { createContext, useContext } from 'react';\nimport { Client, createClient } from './client';\n\n// We assume some default options here; mainly not to actually be used\n// but not to error catastrophically if someone is just playing around\nconst defaultClient = createClient({ url: '/graphql' });\n\nexport const Context = createContext<Client>(defaultClient);\nexport const Provider = Context.Provider;\nexport const Consumer = Context.Consumer;\n\nlet hasWarnedAboutDefault = false;\n\nexport const useClient = (): Client => {\n  const client = useContext(Context);\n\n  if (\n    process.env.NODE_ENV !== 'production' &&\n    client === defaultClient &&\n    !hasWarnedAboutDefault\n  ) {\n    hasWarnedAboutDefault = true;\n\n    console.warn(\n      \"Default Client: No client has been specified using urql's Provider.\" +\n        'This means that urql will be falling back to defaults including making ' +\n        'requests to `/graphql`.\\n' +\n        \"If that's not what you want, please create a client and add a Provider.\"\n    );\n  }\n\n  return client;\n};\n","export const initialState = {\n  fetching: false,\n  stale: false,\n  error: undefined,\n  data: undefined,\n  extensions: undefined,\n};\n","import { DocumentNode } from 'graphql';\nimport { useState, useCallback } from 'react';\nimport { pipe, toPromise } from 'wonka';\nimport { useClient } from '../context';\nimport { OperationResult, OperationContext } from '../types';\nimport { CombinedError, createRequest } from '../utils';\nimport { initialState } from './constants';\n\nexport interface UseMutationState<T> {\n  fetching: boolean;\n  stale: boolean;\n  data?: T;\n  error?: CombinedError;\n  extensions?: Record<string, any>;\n}\n\nexport type UseMutationResponse<T, V> = [\n  UseMutationState<T>,\n  (\n    variables?: V,\n    context?: Partial<OperationContext>\n  ) => Promise<OperationResult<T>>\n];\n\nexport const useMutation = <T = any, V = object>(\n  query: DocumentNode | string\n): UseMutationResponse<T, V> => {\n  const client = useClient();\n\n  const [state, setState] = useState<UseMutationState<T>>(initialState);\n\n  const executeMutation = useCallback(\n    (variables?: V, context?: Partial<OperationContext>) => {\n      setState({ ...initialState, fetching: true });\n\n      const request = createRequest(query, variables as any);\n\n      return pipe(\n        client.executeMutation(request, context || {}),\n        toPromise\n      ).then(result => {\n        setState({\n          fetching: false,\n          stale: !!result.stale,\n          data: result.data,\n          error: result.error,\n          extensions: result.extensions,\n        });\n        return result;\n      });\n    },\n    [client, query, setState]\n  );\n\n  return [state, executeMutation];\n};\n","/* eslint-disable @typescript-eslint/no-use-before-define */\n/* eslint-disable react-hooks/exhaustive-deps */\n\nimport { useMemo, useEffect } from 'react';\nimport { Subscription, Unsubscribe, useSubscription } from 'use-subscription';\n\nimport {\n  Source,\n  fromValue,\n  makeSubject,\n  pipe,\n  map,\n  concat,\n  onPush,\n  publish,\n  subscribe,\n} from 'wonka';\n\nexport const useSource = <T>(source: Source<T>, init: T): T =>\n  useSubscription(\n    useMemo((): Subscription<T> => {\n      let hasUpdate = false;\n      let currentValue: T = init;\n\n      const updateValue = pipe(\n        source,\n        onPush(value => {\n          currentValue = value;\n        })\n      );\n\n      return {\n        getCurrentValue(): T {\n          if (!hasUpdate) publish(updateValue).unsubscribe();\n          return currentValue;\n        },\n        subscribe(onValue: () => void): Unsubscribe {\n          return pipe(\n            updateValue,\n            subscribe(() => {\n              hasUpdate = true;\n              onValue();\n              hasUpdate = false;\n            })\n          ).unsubscribe as Unsubscribe;\n        },\n      };\n    }, [source])\n  );\n\nexport const useBehaviourSubject = <T>(value: T) => {\n  const state = useMemo((): [Source<T>, (value: T) => void] => {\n    let prevValue = value;\n\n    const subject = makeSubject<T>();\n    const prevValue$ = pipe(\n      fromValue(value),\n      map(() => prevValue)\n    );\n\n    const source = concat([prevValue$, subject.source]);\n\n    const next = (value: T) => {\n      subject.next((prevValue = value));\n    };\n\n    return [source, next];\n  }, []);\n\n  useEffect(() => {\n    state[1](value);\n  }, [state, value]);\n\n  return state;\n};\n","import { DocumentNode } from 'graphql';\nimport { useRef, useMemo } from 'react';\nimport { GraphQLRequest } from '../types';\nimport { createRequest } from '../utils';\n\n/** Creates a request from a query and variables but preserves reference equality if the key isn't changing */\nexport const useRequest = (\n  query: string | DocumentNode,\n  variables?: any\n): GraphQLRequest => {\n  const prev = useRef<undefined | GraphQLRequest>(undefined);\n\n  return useMemo(() => {\n    const request = createRequest(query, variables);\n    // We manually ensure reference equality if the key hasn't changed\n    if (prev.current !== undefined && prev.current.key === request.key) {\n      return prev.current;\n    } else {\n      prev.current = request;\n      return request;\n    }\n  }, [query, variables]);\n};\n","import { DocumentNode } from 'graphql';\nimport { useCallback, useMemo } from 'react';\nimport { pipe, concat, fromValue, switchMap, map, scan } from 'wonka';\n\nimport { useClient } from '../context';\nimport { OperationContext, RequestPolicy } from '../types';\nimport { CombinedError } from '../utils';\nimport { useSource, useBehaviourSubject } from './useSource';\nimport { useRequest } from './useRequest';\nimport { initialState } from './constants';\n\nexport interface UseQueryArgs<V> {\n  query: string | DocumentNode;\n  variables?: V;\n  requestPolicy?: RequestPolicy;\n  pollInterval?: number;\n  context?: Partial<OperationContext>;\n  pause?: boolean;\n}\n\nexport interface UseQueryState<T> {\n  fetching: boolean;\n  stale: boolean;\n  data?: T;\n  error?: CombinedError;\n  extensions?: Record<string, any>;\n}\n\nexport type UseQueryResponse<T> = [\n  UseQueryState<T>,\n  (opts?: Partial<OperationContext>) => void\n];\n\nexport const useQuery = <T = any, V = object>(\n  args: UseQueryArgs<V>\n): UseQueryResponse<T> => {\n  const client = useClient();\n\n  // This creates a request which will keep a stable reference\n  // if request.key doesn't change\n  const request = useRequest(args.query, args.variables);\n\n  // Create a new query-source from client.executeQuery\n  const makeQuery$ = useCallback(\n    (opts?: Partial<OperationContext>) => {\n      return client.executeQuery(request, {\n        requestPolicy: args.requestPolicy,\n        pollInterval: args.pollInterval,\n        ...args.context,\n        ...opts,\n      });\n    },\n    [client, request, args.requestPolicy, args.pollInterval, args.context]\n  );\n\n  const [query$$, update] = useBehaviourSubject(\n    useMemo(() => (args.pause ? null : makeQuery$()), [args.pause, makeQuery$])\n  );\n\n  const state = useSource(\n    useMemo(() => {\n      return pipe(\n        query$$,\n        switchMap(query$ => {\n          if (!query$) return fromValue({ fetching: false, stale: false });\n\n          return concat([\n            // Initially set fetching to true\n            fromValue({ fetching: true, stale: false }),\n            pipe(\n              query$,\n              map(({ stale, data, error, extensions }) => ({\n                fetching: false,\n                stale: !!stale,\n                data,\n                error,\n                extensions,\n              }))\n            ),\n            // When the source proactively closes, fetching is set to false\n            fromValue({ fetching: false, stale: false }),\n          ]);\n        }),\n        // The individual partial results are merged into each previous result\n        scan(\n          (result, partial) => ({\n            ...result,\n            ...partial,\n          }),\n          initialState\n        )\n      );\n    }, [query$$]),\n    initialState\n  );\n\n  // This is the imperative execute function passed to the user\n  const executeQuery = useCallback(\n    (opts?: Partial<OperationContext>) => update(makeQuery$(opts)),\n    [update, makeQuery$]\n  );\n\n  return [state, executeQuery];\n};\n","import { DocumentNode } from 'graphql';\nimport { useCallback, useRef, useMemo } from 'react';\nimport { pipe, concat, fromValue, switchMap, map, scan } from 'wonka';\n\nimport { useClient } from '../context';\nimport { CombinedError } from '../utils';\nimport { useSource, useBehaviourSubject } from './useSource';\nimport { OperationContext } from '../types';\nimport { useRequest } from './useRequest';\nimport { initialState } from './constants';\n\nexport interface UseSubscriptionArgs<V> {\n  query: DocumentNode | string;\n  variables?: V;\n  pause?: boolean;\n  context?: Partial<OperationContext>;\n}\n\nexport type SubscriptionHandler<T, R> = (prev: R | undefined, data: T) => R;\n\nexport interface UseSubscriptionState<T> {\n  fetching: boolean;\n  stale: boolean;\n  data?: T;\n  error?: CombinedError;\n  extensions?: Record<string, any>;\n}\n\nexport type UseSubscriptionResponse<T> = [\n  UseSubscriptionState<T>,\n  (opts?: Partial<OperationContext>) => void\n];\n\nexport const useSubscription = <T = any, R = T, V = object>(\n  args: UseSubscriptionArgs<V>,\n  handler?: SubscriptionHandler<T, R>\n): UseSubscriptionResponse<R> => {\n  const client = useClient();\n\n  // Update handler on constant ref, since handler changes shouldn't\n  // trigger a new subscription run\n  const handlerRef = useRef(handler);\n  handlerRef.current = handler;\n\n  // This creates a request which will keep a stable reference\n  // if request.key doesn't change\n  const request = useRequest(args.query, args.variables);\n\n  // Create a new subscription-source from client.executeSubscription\n  const makeSubscription$ = useCallback(\n    (opts?: Partial<OperationContext>) => {\n      return client.executeSubscription(request, { ...args.context, ...opts });\n    },\n    [client, request, args.context]\n  );\n\n  const [subscription$$, update] = useBehaviourSubject(\n    useMemo(() => (args.pause ? null : makeSubscription$()), [\n      args.pause,\n      makeSubscription$,\n    ])\n  );\n\n  const state = useSource(\n    useMemo(() => {\n      return pipe(\n        subscription$$,\n        switchMap(subscription$ => {\n          if (!subscription$) return fromValue({ fetching: false });\n\n          return concat([\n            // Initially set fetching to true\n            fromValue({ fetching: true, stale: false }),\n            pipe(\n              subscription$,\n              map(({ stale, data, error, extensions }) => ({\n                fetching: true,\n                stale: !!stale,\n                data,\n                error,\n                extensions,\n              }))\n            ),\n            // When the source proactively closes, fetching is set to false\n            fromValue({ fetching: false, stale: false }),\n          ]);\n        }),\n        // The individual partial results are merged into each previous result\n        scan((result, partial: any) => {\n          const { current: handler } = handlerRef;\n          // If a handler has been passed, it's used to merge new data in\n          const data =\n            partial.data !== undefined\n              ? typeof handler === 'function'\n                ? handler(result.data, partial.data)\n                : partial.data\n              : result.data;\n          return { ...result, ...partial, data };\n        }, initialState)\n      );\n    }, [subscription$$]),\n    initialState\n  );\n\n  // This is the imperative execute function passed to the user\n  const executeSubscription = useCallback(\n    (opts?: Partial<OperationContext>) => update(makeSubscription$(opts)),\n    [update, makeSubscription$]\n  );\n\n  return [state, executeSubscription];\n};\n","import { ReactElement } from 'react';\nimport { DocumentNode } from 'graphql';\nimport { OperationResult, OperationContext } from '../types';\nimport { useMutation, UseMutationState } from '../hooks';\n\nexport interface MutationProps<T, V> {\n  query: DocumentNode | string;\n  children: (arg: MutationState<T, V>) => ReactElement<any>;\n}\n\nexport interface MutationState<T, V> extends UseMutationState<T> {\n  executeMutation: (\n    variables?: V,\n    context?: Partial<OperationContext>\n  ) => Promise<OperationResult<T>>;\n}\n\nexport function Mutation<T = any, V = any>(\n  props: MutationProps<T, V>\n): ReactElement<any> {\n  const [state, executeMutation] = useMutation<T, V>(props.query);\n  return props.children({ ...state, executeMutation });\n}\n","import { ReactElement } from 'react';\nimport { OperationContext } from '../types';\nimport { useQuery, UseQueryArgs, UseQueryState } from '../hooks';\n\nexport interface QueryProps<T, V> extends UseQueryArgs<V> {\n  children: (arg: QueryState<T>) => ReactElement<any>;\n}\n\nexport interface QueryState<T> extends UseQueryState<T> {\n  executeQuery: (opts?: Partial<OperationContext>) => void;\n}\n\nexport function Query<T = any, V = any>(\n  props: QueryProps<T, V>\n): ReactElement<any> {\n  const [state, executeQuery] = useQuery<T, V>(props);\n  return props.children({ ...state, executeQuery });\n}\n","import { ReactElement } from 'react';\nimport { OperationContext } from '../types';\n\nimport {\n  useSubscription,\n  UseSubscriptionArgs,\n  UseSubscriptionState,\n  SubscriptionHandler,\n} from '../hooks';\n\nexport interface SubscriptionProps<T, R, V> extends UseSubscriptionArgs<V> {\n  handler?: SubscriptionHandler<T, R>;\n  children: (arg: SubscriptionState<R>) => ReactElement<any>;\n}\n\nexport interface SubscriptionState<T> extends UseSubscriptionState<T> {\n  executeSubscription: (opts?: Partial<OperationContext>) => void;\n}\n\nexport function Subscription<T = any, R = T, V = any>(\n  props: SubscriptionProps<T, R, V>\n): ReactElement<any> {\n  const [state, executeSubscription] = useSubscription<T, R, V>(\n    props,\n    props.handler\n  );\n  return props.children({ ...state, executeSubscription });\n}\n"],"names":["const","defaultClient","createClient","url","Context","createContext","Provider","Consumer","let","hasWarnedAboutDefault","useClient","client","useContext","process","env","NODE_ENV","console","warn","initialState","fetching","stale","error","undefined","data","extensions","useMutation","query","useState","result","setState","useCallback","variables","context","request","createRequest","toPromise","executeMutation","then","useSource","source","init","useSubscription","useMemo","hasUpdate","currentValue","updateValue","onPush","value","getCurrentValue","publish","unsubscribe","subscribe","onValue","useBehaviourSubject","state","prevValue","subject","makeSubject","prevValue$","map","fromValue","concat","next","useEffect","useRequest","prev","useRef","current","key","partial","query$","useQuery","args","makeQuery$","opts","executeQuery","requestPolicy","pollInterval","pause","scan","switchMap","query$$","update","subscription$","handler","handlerRef","makeSubscription$","executeSubscription","subscription$$","Mutation","props","children","Query","Subscription"],"mappings":";;;;;;;;;;;;;;AAKAA,IAAMC,gBAAgBC,kBAAa;EAAEC,KAAK;;;IAE7BC,UAAUC,oBAAsBJ;;IAChCK,WAAWF,QAAQE;;IACnBC,WAAWH,QAAQG;;AAEhCC,IAAIC,yBAAwB;;IAEfC;MACLC,SAASC,iBAAWR;MAGC,iBAAzBS,QAAQC,IAAIC,YACZJ,WAAWV,kBACVQ,uBACD;IACAA,yBAAwB;IAExBO,QAAQC,KACN;;SAOGN;;;AC/BFX,IAAMkB,eAAe;EAC1BC,WAAU;EACVC,QAAO;EACPC,YAAOC;EACPC,WAAMD;EACNE,iBAAYF;;;ICmBDG,uBACXC;MAEMf,SAASD;YAEWiB,eAA8BT;;gBAW7CU;IACLC,SAAS;MACPV,WAAU;MACVC,SAASQ,OAAOR;MAChBG,MAAMK,OAAOL;MACbF,OAAOO,OAAOP;MACdG,YAAYI,OAAOJ;;WAEdI;;SAMN,UAvBiBE,4BACrBC,WAAeC;IACdH,2CAAcX;MAAcC,WAAU;;QAEhCc,UAAUC,oBAAcR,OAAOK;WAInCI,gBADAxB,OAAOyB,gBAAgBH,SAASD,WAAW,KAE3CK;MAWJ,EAAC1B,QAAQe,OAAOG;;;ACjCb7B,IAAMsC,qBAAgBC,QAAmBC;SAC9CC,kCACEC;QACMC,aAAY;QACZC,eAAkBJ;QAEhBK,cAEJC,uBAAOC;MACLH,eAAeG;OADjBD,CADAP;WAMK;MACLS;aACOL;UAAWM,cAAQJ,aAAaK;;eAC9BN;;MAETO,gCAAUC;eAGND;UACER,aAAY;UACZS;UACAT,aAAY;WAHdQ,CADAN,aAMAK;;;MAGL,EAACX;;;AAGDvC,IAAMqD,+BAA0BN;MAC/BO,QAAQZ;QACRa,YAAYR;QAEVS,UAAUC;QACVC,aAEJC;aAAUJ;OAAVI,CADAC,gBAAUb;WAUL,EANQc,aAAO,EAACH,YAAYF,QAAQjB,oBAE7BQ;MACZS,QAAQM,KAAMP,YAAYR;;MAI3B;EAEHgB;IACET,MAAM,GAAGP;MACR,EAACO,OAAOP;SAEJO;;;ACnEFtD,IAAMgE,sBACXtC,OACAK;MAEMkC,OAAOC,kBAAmC5C;SAEzCoB;QACCT,UAAUC,oBAAcR,OAAOK;aAEhBT,MAAjB2C,KAAKE,WAAyBF,KAAKE,QAAQC,QAAQnC,QAAQmC;aACtDH,KAAKE;WACP;MACLF,KAAKE,UAAUlC;aACRA;;MAER,EAACP,OAAOK;;;cCgEFH,QAAQyC;2CACJzC,SACAyC;;;;SAhB4C;IAC3ClD,WAAU;IACVC;;;;;;;eAVEkD;OACHA;WAAeV,gBAAU;MAAEzC,WAAU;MAAOC,QAAO;;;SAEjDyC,aAAO,EAEZD,gBAAU;IAAEzC,WAAU;IAAMC,QAAO;MAGjCuC,gBAAAA,CADAW,SAUFV,gBAAU;IAAEzC,WAAU;IAAOC,QAAO;;;;IA/CnCmD,oBACXC;MAEM7D,SAASD;MAITuB,UAAU+B,WAAWQ,KAAK9C,OAAO8C,KAAKzC;MAGtC0C,aAAa3C,4BAChB4C;WACQ/D,OAAOgE,aAAa1C;MACzB2C,eAAeJ,KAAKI;MACpBC,cAAcL,KAAKK;OAChBL,KAAKxC,UACL0C;MAGP,EAAC/D,QAAQsB,SAASuC,KAAKI,eAAeJ,KAAKK,cAAcL,KAAKxC;YAGtCqB,oBACxBX;WAAe8B,KAAKM,QAAQ,OAAOL;MAAe,EAACD,KAAKM,OAAOL;;;SA8C1D,EA3COnC,UACZI;WAwBIqC,iBAKE7D,cA1BF8D,sBAAAA,CADAC;MA8BD,EAACA,YACJ/D,eAImBY,4BAClB4C;WAAqCQ,OAAOT,WAAWC;MACxD,EAACQ,QAAQT;;;;SCxB8C;IAC3CtD,WAAU;IACVC;;;;;;;iBAVE+D;OACHA;WAAsBvB,gBAAU;MAAEzC,WAAU;;;SAE1C0C,aAAO,EAEZD,gBAAU;IAAEzC,WAAU;IAAMC,QAAO;MAGjCuC,kBAAAA,CADAwB,gBAUFvB,gBAAU;IAAEzC,WAAU;IAAOC,QAAO;;;;IAnDnCqB,2BACX+B,MACAY;MAEMzE,SAASD;MAIT2E,aAAanB,aAAOkB;EAC1BC,WAAWlB,UAAUiB;MAIfnD,UAAU+B,WAAWQ,KAAK9C,OAAO8C,KAAKzC;MAGtCuD,oBAAoBxD,4BACvB4C;WACQ/D,OAAO4E,oBAAoBtD,2CAAcuC,KAAKxC,UAAY0C;MAEnE,EAAC/D,QAAQsB,SAASuC,KAAKxC;YAGQqB,oBAC/BX;WAAe8B,KAAKM,QAAQ,OAAOQ;MAAsB,EACvDd,KAAKM,OACLQ;;;gBA6BQ1D,QAAQyC;;QAGN9C,YACaD,MAAjB+C,QAAQ9C,OACe,qBAAZ6D,UACLA,QAAQxD,OAAOL,MAAM8C,QAAQ9C,QAC7B8C,QAAQ9C,OACVK,OAAOL;4DACDK,SAAWyC;YAAS9C;;;SAajC,EA/COe,UACZI;WAwBIqC,iBAUG7D,cA/BH8D,wBAAAA,CADAQ;MAkCD,EAACA,mBACJtE,eAI0BY,4BACzB4C;WAAqCQ,OAAOI,kBAAkBZ;MAC/D,EAACQ,QAAQI;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4BC1FGG,SACdC;YAEiCjE,YAAkBiE,MAAMhE;;SAClDgE,MAAMC;qBAAqBvD;;;;;;yBCTpBwD,MACdF;YAE8BnB,SAAemB;;SACtCA,MAAMC;kBAAqBhB;;;;gCCGpBkB,aACdH;YAEqCjD,gBACnCiD,OACAA,MAAMN;;SAEDM,MAAMC;yBAAqBJ;;;;;;;;;;"}
\ No newline at end of file
diff --git a/node_modules/urql/dist/es/core.js b/node_modules/urql/dist/es/core.js
index 5e262f6..b11eaad 100644
--- a/node_modules/urql/dist/es/core.js
+++ b/node_modules/urql/dist/es/core.js
@@ -280,12 +280,12 @@ var subscriptionExchange = function (ref) {
               },
               complete: function () {
                 if (!isComplete) {
+                  isComplete = !0;
                   client.reexecuteOperation(_extends(_extends({}, operation), {
                     operationName: "teardown"
                   }));
+                  complete();
                 }
-
-                complete();
               }
             });
             return function () {
@@ -416,14 +416,23 @@ var createFetchSource = function (operation) {
       signal: void 0 !== abortController ? abortController.signal : void 0
     });
 
-    executeFetch(operation, fetchOptions).then(function (result) {
-      if (void 0 !== result) {
-        next(result);
-      }
+    var ended = !1;
+    Promise.resolve().then(function () {
+      return ended ? void 0 : executeFetch(operation, fetchOptions);
+    }).then(function (result) {
+      if (!ended) {
+        ended = !0;
+
+        if (result) {
+          next(result);
+        }
 
-      complete();
+        complete();
+      }
     });
     return function () {
+      ended = !0;
+
       if (void 0 !== abortController) {
         abortController.abort();
       }
diff --git a/node_modules/urql/dist/es/core.js.map b/node_modules/urql/dist/es/core.js.map
index 9d99063..2154459 100644
--- a/node_modules/urql/dist/es/core.js.map
+++ b/node_modules/urql/dist/es/core.js.map
@@ -1 +1 @@
-{"version":3,"file":"core.js","sources":["../../src/exchanges/ssr.ts","../../src/exchanges/cache.ts","../../src/exchanges/subscription.ts","../../src/exchanges/debug.ts","../../src/exchanges/dedup.ts","../../src/exchanges/fetch.ts","../../src/exchanges/fallback.ts","../../src/exchanges/compose.ts","../../src/exchanges/index.ts","../../src/client.ts"],"sourcesContent":["import { pipe, share, filter, merge, map, tap } from 'wonka';\nimport { Exchange, OperationResult, Operation } from '../types';\nimport { CombinedError } from '../utils';\n\nexport interface SerializedResult {\n  data?: any;\n  error?: {\n    networkError?: string;\n    graphQLErrors: string[];\n  };\n}\n\nexport interface SSRData {\n  [key: string]: SerializedResult;\n}\n\nexport interface SSRExchangeParams {\n  isClient?: boolean;\n  initialState?: SSRData;\n}\n\nexport interface SSRExchange extends Exchange {\n  /** Rehydrates cached data */\n  restoreData(data: SSRData): void;\n  /** Extracts cached data */\n  extractData(): SSRData;\n}\n\nconst shouldSkip = ({ operationName }: Operation) =>\n  operationName !== 'subscription' && operationName !== 'query';\n\n/** Serialize an OperationResult to plain JSON */\nconst serializeResult = ({\n  data,\n  error,\n}: OperationResult): SerializedResult => {\n  const result: SerializedResult = { data, error: undefined };\n  if (error !== undefined) {\n    result.error = {\n      networkError: '' + error.networkError,\n      graphQLErrors: error.graphQLErrors.map(x => '' + x),\n    };\n  }\n\n  return result;\n};\n\n/** Deserialize plain JSON to an OperationResult */\nconst deserializeResult = (\n  operation: Operation,\n  result: SerializedResult\n): OperationResult => {\n  const { error, data } = result;\n  const deserialized: OperationResult = {\n    operation,\n    data,\n    extensions: undefined,\n    error: undefined,\n  };\n  if (error !== undefined) {\n    deserialized.error = new CombinedError({\n      networkError: new Error(error.networkError),\n      graphQLErrors: error.graphQLErrors,\n    });\n  }\n\n  return deserialized;\n};\n\n/** The ssrExchange can be created to capture data during SSR and also to rehydrate it on the client */\nexport const ssrExchange = (params?: SSRExchangeParams): SSRExchange => {\n  const data: SSRData = {};\n\n  const isCached = (operation: Operation) => {\n    return !shouldSkip(operation) && data[operation.key] !== undefined;\n  };\n\n  // The SSR Exchange is a temporary cache that can populate results into data for suspense\n  // On the client it can be used to retrieve these temporary results from a rehydrated cache\n  const ssr: SSRExchange = ({ client, forward }) => ops$ => {\n    // params.isClient tells us whether we're on the client-side\n    // By default we assume that we're on the client if suspense-mode is disabled\n    const isClient =\n      params && typeof params.isClient === 'boolean'\n        ? !!params.isClient\n        : !client.suspense;\n\n    const sharedOps$ = share(ops$);\n\n    let forwardedOps$ = pipe(\n      sharedOps$,\n      filter(op => !isCached(op)),\n      forward\n    );\n\n    // NOTE: Since below we might delete the cached entry after accessing\n    // it once, cachedOps$ needs to be merged after forwardedOps$\n    let cachedOps$ = pipe(\n      sharedOps$,\n      filter(op => isCached(op)),\n      map(op => {\n        const serialized = data[op.key];\n        return deserializeResult(op, serialized);\n      })\n    );\n\n    if (!isClient) {\n      // On the server we cache results in the cache as they're resolved\n      forwardedOps$ = pipe(\n        forwardedOps$,\n        tap((result: OperationResult) => {\n          const { operation } = result;\n          if (!shouldSkip(operation)) {\n            const serialized = serializeResult(result);\n            data[operation.key] = serialized;\n          }\n        })\n      );\n    } else {\n      // On the client we delete results from the cache as they're resolved\n      cachedOps$ = pipe(\n        cachedOps$,\n        tap((result: OperationResult) => {\n          delete data[result.operation.key];\n        })\n      );\n    }\n\n    return merge([forwardedOps$, cachedOps$]);\n  };\n\n  ssr.restoreData = (restore: SSRData) => Object.assign(data, restore);\n  ssr.extractData = () => Object.assign({}, data);\n\n  if (params && params.initialState) {\n    ssr.restoreData(params.initialState);\n  }\n\n  return ssr;\n};\n","/* eslint-disable @typescript-eslint/no-use-before-define */\nimport { filter, map, merge, pipe, share, tap } from 'wonka';\n\nimport { Client } from '../client';\nimport { Exchange, Operation, OperationResult } from '../types';\nimport {\n  addMetadata,\n  collectTypesFromResponse,\n  formatDocument,\n} from '../utils';\n\ntype ResultCache = Map<number, OperationResult>;\n\ninterface OperationCache {\n  [key: string]: Set<number>;\n}\n\nconst shouldSkip = ({ operationName }: Operation) =>\n  operationName !== 'mutation' && operationName !== 'query';\n\nexport const cacheExchange: Exchange = ({ forward, client }) => {\n  const resultCache = new Map() as ResultCache;\n  const operationCache = Object.create(null) as OperationCache;\n\n  // Adds unique typenames to query (for invalidating cache entries)\n  const mapTypeNames = (operation: Operation): Operation => ({\n    ...operation,\n    query: formatDocument(operation.query),\n  });\n\n  const handleAfterMutation = afterMutation(\n    resultCache,\n    operationCache,\n    client\n  );\n\n  const handleAfterQuery = afterQuery(resultCache, operationCache);\n\n  const isOperationCached = operation => {\n    const {\n      key,\n      operationName,\n      context: { requestPolicy },\n    } = operation;\n    return (\n      operationName === 'query' &&\n      requestPolicy !== 'network-only' &&\n      (requestPolicy === 'cache-only' || resultCache.has(key))\n    );\n  };\n\n  return ops$ => {\n    const sharedOps$ = share(ops$);\n\n    const cachedOps$ = pipe(\n      sharedOps$,\n      filter(op => !shouldSkip(op) && isOperationCached(op)),\n      map(operation => {\n        const cachedResult = resultCache.get(operation.key);\n        const result: OperationResult = {\n          ...cachedResult,\n          operation: addMetadata(operation, {\n            cacheOutcome: cachedResult ? 'hit' : 'miss',\n          }),\n        };\n\n        if (operation.context.requestPolicy === 'cache-and-network') {\n          result.stale = true;\n          reexecuteOperation(client, operation);\n        }\n\n        return result;\n      })\n    );\n\n    const forwardedOps$ = pipe(\n      merge([\n        pipe(\n          sharedOps$,\n          filter(op => !shouldSkip(op) && !isOperationCached(op)),\n          map(mapTypeNames)\n        ),\n        pipe(\n          sharedOps$,\n          filter(op => shouldSkip(op))\n        ),\n      ]),\n      map(op => addMetadata(op, { cacheOutcome: 'miss' })),\n      forward,\n      tap(response => {\n        if (\n          response.operation &&\n          response.operation.operationName === 'mutation'\n        ) {\n          handleAfterMutation(response);\n        } else if (\n          response.operation &&\n          response.operation.operationName === 'query'\n        ) {\n          handleAfterQuery(response);\n        }\n      })\n    );\n\n    return merge([cachedOps$, forwardedOps$]);\n  };\n};\n\n// Reexecutes a given operation with the default requestPolicy\nconst reexecuteOperation = (client: Client, operation: Operation) => {\n  return client.reexecuteOperation({\n    ...operation,\n    context: {\n      ...operation.context,\n      requestPolicy: 'network-only',\n    },\n  });\n};\n\n// Invalidates the cache given a mutation's response\nexport const afterMutation = (\n  resultCache: ResultCache,\n  operationCache: OperationCache,\n  client: Client\n) => (response: OperationResult) => {\n  const pendingOperations = new Set<number>();\n\n  collectTypesFromResponse(response.data).forEach(typeName => {\n    const operations =\n      operationCache[typeName] || (operationCache[typeName] = new Set());\n    operations.forEach(key => {\n      pendingOperations.add(key);\n    });\n    operations.clear();\n  });\n\n  pendingOperations.forEach(key => {\n    if (resultCache.has(key)) {\n      const operation = (resultCache.get(key) as OperationResult).operation;\n      resultCache.delete(key);\n      reexecuteOperation(client, operation);\n    }\n  });\n};\n\n// Mark typenames on typenameInvalidate for early invalidation\nconst afterQuery = (\n  resultCache: ResultCache,\n  operationCache: OperationCache\n) => (response: OperationResult) => {\n  const { operation, data, error } = response;\n\n  if (data === undefined || data === null) {\n    return;\n  }\n\n  resultCache.set(operation.key, { operation, data, error });\n\n  collectTypesFromResponse(response.data).forEach(typeName => {\n    const operations =\n      operationCache[typeName] || (operationCache[typeName] = new Set());\n    operations.add(operation.key);\n  });\n};\n","import { print } from 'graphql';\n\nimport {\n  filter,\n  make,\n  merge,\n  mergeMap,\n  pipe,\n  share,\n  Source,\n  takeUntil,\n} from 'wonka';\n\nimport { makeResult, makeErrorResult } from '../utils';\n\nimport {\n  Exchange,\n  ExecutionResult,\n  Operation,\n  OperationContext,\n  OperationResult,\n} from '../types';\n\nexport interface ObserverLike<T> {\n  next: (value: T) => void;\n  error: (err: any) => void;\n  complete: () => void;\n}\n\n/** An abstract observable interface conforming to: https://github.com/tc39/proposal-observable */\nexport interface ObservableLike<T> {\n  subscribe(\n    observer: ObserverLike<T>\n  ): {\n    unsubscribe: () => void;\n  };\n}\n\nexport interface SubscriptionOperation {\n  query: string;\n  variables?: object;\n  key: string;\n  context: OperationContext;\n}\n\nexport type SubscriptionForwarder = (\n  operation: SubscriptionOperation\n) => ObservableLike<ExecutionResult & { extensions?: Record<string, any> }>;\n\n/** This is called to create a subscription and needs to be hooked up to a transport client. */\nexport interface SubscriptionExchangeOpts {\n  // This has been modelled to work with subscription-transport-ws\n  // See: https://github.com/apollographql/subscriptions-transport-ws#requestoptions--observableexecutionresult-returns-observable-to-execute-the-operation\n  forwardSubscription: SubscriptionForwarder;\n}\n\nconst isSubscriptionOperation = (operation: Operation) =>\n  operation.operationName === 'subscription';\n\nexport const subscriptionExchange = ({\n  forwardSubscription,\n}: SubscriptionExchangeOpts): Exchange => ({ client, forward }) => {\n  const createSubscriptionSource = (\n    operation: Operation\n  ): Source<OperationResult> => {\n    // This excludes the query's name as a field although subscription-transport-ws does accept it since it's optional\n    const observableish = forwardSubscription({\n      key: operation.key.toString(36),\n      query: print(operation.query),\n      variables: operation.variables,\n      context: { ...operation.context },\n    });\n\n    return make<OperationResult>(({ next, complete }) => {\n      let isComplete = false;\n\n      const sub = observableish.subscribe({\n        next: result => next(makeResult(operation, result)),\n        error: err => next(makeErrorResult(operation, err)),\n        complete: () => {\n          if (!isComplete) {\n            client.reexecuteOperation({\n              ...operation,\n              operationName: 'teardown',\n            });\n          }\n\n          complete();\n        },\n      });\n\n      return () => {\n        isComplete = true;\n        sub.unsubscribe();\n      };\n    });\n  };\n\n  return ops$ => {\n    const sharedOps$ = share(ops$);\n    const subscriptionResults$ = pipe(\n      sharedOps$,\n      filter(isSubscriptionOperation),\n      mergeMap(operation => {\n        const { key } = operation;\n        const teardown$ = pipe(\n          sharedOps$,\n          filter(op => op.operationName === 'teardown' && op.key === key)\n        );\n\n        return pipe(createSubscriptionSource(operation), takeUntil(teardown$));\n      })\n    );\n\n    const forward$ = pipe(\n      sharedOps$,\n      filter(op => !isSubscriptionOperation(op)),\n      forward\n    );\n\n    return merge([subscriptionResults$, forward$]);\n  };\n};\n","import { pipe, tap } from 'wonka';\nimport { Exchange } from '../types';\n\nexport const debugExchange: Exchange = ({ forward }) => {\n  if (process.env.NODE_ENV === 'production') {\n    return ops$ => forward(ops$);\n  } else {\n    return ops$ =>\n      pipe(\n        ops$,\n        // eslint-disable-next-line no-console\n        tap(op => console.log('[Exchange debug]: Incoming operation: ', op)),\n        forward,\n        tap(result =>\n          // eslint-disable-next-line no-console\n          console.log('[Exchange debug]: Completed operation: ', result)\n        )\n      );\n  }\n};\n","import { filter, pipe, tap } from 'wonka';\nimport { Exchange, Operation, OperationResult } from '../types';\n\n/** A default exchange for debouncing GraphQL requests. */\nexport const dedupExchange: Exchange = ({ forward }) => {\n  const inFlightKeys = new Set<number>();\n\n  const filterIncomingOperation = (operation: Operation) => {\n    const { key, operationName } = operation;\n    if (operationName === 'teardown') {\n      inFlightKeys.delete(key);\n      return true;\n    } else if (operationName !== 'query' && operationName !== 'subscription') {\n      return true;\n    }\n\n    const isInFlight = inFlightKeys.has(key);\n    inFlightKeys.add(key);\n    return !isInFlight;\n  };\n\n  const afterOperationResult = ({ operation }: OperationResult) => {\n    inFlightKeys.delete(operation.key);\n  };\n\n  return ops$ => {\n    const forward$ = pipe(ops$, filter(filterIncomingOperation));\n    return pipe(forward(forward$), tap(afterOperationResult));\n  };\n};\n","/* eslint-disable @typescript-eslint/no-use-before-define */\nimport { Kind, DocumentNode, OperationDefinitionNode, print } from 'graphql';\nimport { filter, make, merge, mergeMap, pipe, share, takeUntil } from 'wonka';\nimport { Exchange, Operation, OperationResult } from '../types';\nimport { makeResult, makeErrorResult } from '../utils';\n\ninterface Body {\n  query: string;\n  variables: void | object;\n  operationName?: string;\n}\n\n/** A default exchange for fetching GraphQL requests. */\nexport const fetchExchange: Exchange = ({ forward }) => {\n  const isOperationFetchable = (operation: Operation) => {\n    const { operationName } = operation;\n    return operationName === 'query' || operationName === 'mutation';\n  };\n\n  return ops$ => {\n    const sharedOps$ = share(ops$);\n    const fetchResults$ = pipe(\n      sharedOps$,\n      filter(isOperationFetchable),\n      mergeMap(operation => {\n        const { key } = operation;\n        const teardown$ = pipe(\n          sharedOps$,\n          filter(op => op.operationName === 'teardown' && op.key === key)\n        );\n\n        return pipe(createFetchSource(operation), takeUntil(teardown$));\n      })\n    );\n\n    const forward$ = pipe(\n      sharedOps$,\n      filter(op => !isOperationFetchable(op)),\n      forward\n    );\n\n    return merge([fetchResults$, forward$]);\n  };\n};\n\nconst getOperationName = (query: DocumentNode): string | null => {\n  const node = query.definitions.find(\n    (node: any): node is OperationDefinitionNode => {\n      return node.kind === Kind.OPERATION_DEFINITION && node.name;\n    }\n  );\n\n  return node !== undefined && node.name ? node.name.value : null;\n};\n\nconst createFetchSource = (operation: Operation) => {\n  if (\n    process.env.NODE_ENV !== 'production' &&\n    operation.operationName === 'subscription'\n  ) {\n    throw new Error(\n      'Received a subscription operation in the httpExchange. You are probably trying to create a subscription. Have you added a subscriptionExchange?'\n    );\n  }\n\n  return make<OperationResult>(({ next, complete }) => {\n    const abortController =\n      typeof AbortController !== 'undefined'\n        ? new AbortController()\n        : undefined;\n\n    const { context } = operation;\n\n    const extraOptions =\n      typeof context.fetchOptions === 'function'\n        ? context.fetchOptions()\n        : context.fetchOptions || {};\n\n    const operationName = getOperationName(operation.query);\n\n    const body: Body = {\n      query: print(operation.query),\n      variables: operation.variables,\n    };\n\n    if (operationName !== null) {\n      body.operationName = operationName;\n    }\n\n    const fetchOptions = {\n      body: JSON.stringify(body),\n      method: 'POST',\n      ...extraOptions,\n      headers: {\n        'content-type': 'application/json',\n        ...extraOptions.headers,\n      },\n      signal:\n        abortController !== undefined ? abortController.signal : undefined,\n    };\n\n    executeFetch(operation, fetchOptions).then(result => {\n      if (result !== undefined) {\n        next(result);\n      }\n\n      complete();\n    });\n\n    return () => {\n      if (abortController !== undefined) {\n        abortController.abort();\n      }\n    };\n  });\n};\n\nconst executeFetch = (operation: Operation, opts: RequestInit) => {\n  const { url, fetch: fetcher } = operation.context;\n\n  let response: Response | undefined;\n\n  return (fetcher || fetch)(url, opts)\n    .then(res => {\n      const { status } = res;\n      const statusRangeEnd = opts.redirect === 'manual' ? 400 : 300;\n      response = res;\n\n      if (status < 200 || status >= statusRangeEnd) {\n        throw new Error(res.statusText);\n      } else {\n        return res.json();\n      }\n    })\n    .then(result => makeResult(operation, result, response))\n    .catch(err => {\n      if (err.name !== 'AbortError') {\n        return makeErrorResult(operation, err, response);\n      }\n    });\n};\n","import { filter, pipe, tap } from 'wonka';\nimport { ExchangeIO, Operation } from '../types';\n\n/** This is always the last exchange in the chain; No operation should ever reach it */\nexport const fallbackExchangeIO: ExchangeIO = ops$ =>\n  pipe(\n    ops$,\n    tap<Operation>(({ operationName }) => {\n      if (\n        operationName !== 'teardown' &&\n        process.env.NODE_ENV !== 'production'\n      ) {\n        console.warn(\n          `No exchange has handled operations of type \"${operationName}\". Check whether you've added an exchange responsible for these operations.`\n        );\n      }\n    }),\n    /* All operations that skipped through the entire exchange chain should be filtered from the output */\n    filter<any>(() => false)\n  );\n","import { Exchange } from '../types';\n\n/** This composes an array of Exchanges into a single ExchangeIO function */\nexport const composeExchanges = (exchanges: Exchange[]): Exchange => {\n  if (exchanges.length === 1) {\n    return exchanges[0];\n  }\n\n  return payload => {\n    return exchanges.reduceRight((forward, exchange) => {\n      return exchange({ client: payload.client, forward });\n    }, payload.forward);\n  };\n};\n","export { ssrExchange } from './ssr';\nexport { cacheExchange } from './cache';\nexport { subscriptionExchange } from './subscription';\nexport { debugExchange } from './debug';\nexport { dedupExchange } from './dedup';\nexport { fetchExchange } from './fetch';\nexport { fallbackExchangeIO } from './fallback';\nexport { composeExchanges } from './compose';\n\nimport { cacheExchange } from './cache';\nimport { dedupExchange } from './dedup';\nimport { fetchExchange } from './fetch';\n\nexport const defaultExchanges = [dedupExchange, cacheExchange, fetchExchange];\n","// This is the entrypoint for the urql/client bundle.\n// It'll be output to dist/es/core.js and dist/cjs/core.js\n// This file also contains the main urql Client\nexport * from './exchanges';\nexport * from './types';\n\nexport {\n  CombinedError,\n  stringifyVariables,\n  createRequest,\n  makeResult,\n  makeErrorResult,\n  formatDocument,\n} from './utils';\n\n/* eslint-disable @typescript-eslint/no-use-before-define */\nimport {\n  filter,\n  makeSubject,\n  onEnd,\n  onStart,\n  pipe,\n  share,\n  Source,\n  take,\n  takeUntil,\n  merge,\n  interval,\n  fromValue,\n  switchMap,\n  publish,\n} from 'wonka';\n\nimport {\n  composeExchanges,\n  defaultExchanges,\n  fallbackExchangeIO,\n} from './exchanges';\n\nimport {\n  Exchange,\n  GraphQLRequest,\n  Operation,\n  OperationContext,\n  OperationResult,\n  OperationType,\n  RequestPolicy,\n  PromisifiedSource,\n} from './types';\n\nimport { createRequest, toSuspenseSource, withPromise } from './utils';\nimport { DocumentNode } from 'graphql';\n\n/** Options for configuring the URQL [client]{@link Client}. */\nexport interface ClientOptions {\n  /** Target endpoint URL such as `https://my-target:8080/graphql`. */\n  url: string;\n  /** Any additional options to pass to fetch. */\n  fetchOptions?: RequestInit | (() => RequestInit);\n  /** An alternative fetch implementation. */\n  fetch?: typeof fetch;\n  /** An ordered array of Exchanges. */\n  exchanges?: Exchange[];\n  /** Activates support for Suspense. */\n  suspense?: boolean;\n  /** The default request policy for requests. */\n  requestPolicy?: RequestPolicy;\n}\n\ninterface ActiveOperations {\n  [operationKey: string]: number;\n}\n\nexport const createClient = (opts: ClientOptions) => new Client(opts);\n\n/** The URQL application-wide client library. Each execute method starts a GraphQL request and returns a stream of results. */\nexport class Client {\n  // These are variables derived from ClientOptions\n  url: string;\n  fetch?: typeof fetch;\n  fetchOptions?: RequestInit | (() => RequestInit);\n  exchange: Exchange;\n  suspense: boolean;\n  requestPolicy: RequestPolicy;\n\n  // These are internals to be used to keep track of operations\n  dispatchOperation: (operation: Operation) => void;\n  operations$: Source<Operation>;\n  results$: Source<OperationResult>;\n  activeOperations = Object.create(null) as ActiveOperations;\n\n  constructor(opts: ClientOptions) {\n    this.url = opts.url;\n    this.fetchOptions = opts.fetchOptions;\n    this.fetch = opts.fetch;\n    this.suspense = !!opts.suspense;\n    this.requestPolicy = opts.requestPolicy || 'cache-first';\n\n    // This subject forms the input of operations; executeOperation may be\n    // called to dispatch a new operation on the subject\n    const { source: operations$, next: nextOperation } = makeSubject<\n      Operation\n    >();\n    this.operations$ = operations$;\n\n    // Internally operations aren't always dispatched immediately\n    // Since exchanges can dispatch and reexecute operations themselves,\n    // if we're inside an exchange we instead queue the operation and flush\n    // them in order after\n    const queuedOperations: Operation[] = [];\n    let isDispatching = false;\n\n    this.dispatchOperation = (operation: Operation) => {\n      queuedOperations.push(operation);\n      if (!isDispatching) {\n        isDispatching = true;\n        let queued;\n        while ((queued = queuedOperations.shift()) !== undefined)\n          nextOperation(queued);\n        isDispatching = false;\n      }\n    };\n\n    const exchanges =\n      opts.exchanges !== undefined ? opts.exchanges : defaultExchanges;\n\n    // All exchange are composed into a single one and are called using the constructed client\n    // and the fallback exchange stream\n    this.exchange = composeExchanges(exchanges);\n\n    // All operations run through the exchanges in a pipeline-like fashion\n    // and this observable then combines all their results\n    this.results$ = share(\n      this.exchange({\n        client: this,\n        forward: fallbackExchangeIO,\n      })(this.operations$)\n    );\n\n    // Prevent the `results$` exchange pipeline from being closed by active\n    // cancellations cascading up from components\n    pipe(this.results$, publish);\n  }\n\n  private createOperationContext = (\n    opts?: Partial<OperationContext>\n  ): OperationContext => ({\n    url: this.url,\n    fetchOptions: this.fetchOptions,\n    fetch: this.fetch,\n    ...opts,\n    requestPolicy: (opts || {}).requestPolicy || this.requestPolicy,\n  });\n\n  createRequestOperation = (\n    type: OperationType,\n    request: GraphQLRequest,\n    opts?: Partial<OperationContext>\n  ): Operation => ({\n    key: request.key,\n    query: request.query,\n    variables: request.variables,\n    operationName: type,\n    context: this.createOperationContext(opts),\n  });\n\n  /** Counts up the active operation key and dispatches the operation */\n  private onOperationStart(operation: Operation) {\n    const { key } = operation;\n    this.activeOperations[key] = (this.activeOperations[key] || 0) + 1;\n    this.dispatchOperation(operation);\n  }\n\n  /** Deletes an active operation's result observable and sends a teardown signal through the exchange pipeline */\n  private onOperationEnd(operation: Operation) {\n    const { key } = operation;\n    const prevActive = this.activeOperations[key] || 0;\n    const newActive = (this.activeOperations[key] =\n      prevActive <= 0 ? 0 : prevActive - 1);\n\n    if (newActive <= 0) {\n      this.dispatchOperation({ ...operation, operationName: 'teardown' });\n    }\n  }\n\n  /** Executes an Operation by sending it through the exchange pipeline It returns an observable that emits all related exchange results and keeps track of this observable's subscribers. A teardown signal will be emitted when no subscribers are listening anymore. */\n  executeRequestOperation(operation: Operation): Source<OperationResult> {\n    const { key, operationName } = operation;\n    const operationResults$ = pipe(\n      this.results$,\n      filter((res: OperationResult) => res.operation.key === key)\n    );\n\n    if (operationName === 'mutation') {\n      // A mutation is always limited to just a single result and is never shared\n      return pipe(\n        operationResults$,\n        onStart<OperationResult>(() => this.dispatchOperation(operation)),\n        take(1)\n      );\n    }\n\n    const teardown$ = pipe(\n      this.operations$,\n      filter(\n        (op: Operation) => op.operationName === 'teardown' && op.key === key\n      )\n    );\n\n    const result$ = pipe(\n      operationResults$,\n      takeUntil(teardown$),\n      onStart<OperationResult>(() => {\n        this.onOperationStart(operation);\n      }),\n      onEnd<OperationResult>(() => {\n        this.onOperationEnd(operation);\n      })\n    );\n\n    return operation.context.suspense !== false &&\n      this.suspense &&\n      operationName === 'query'\n      ? toSuspenseSource<OperationResult>(result$ as Source<OperationResult>)\n      : (result$ as Source<OperationResult>);\n  }\n\n  reexecuteOperation = (operation: Operation) => {\n    // Reexecute operation only if any subscribers are still subscribed to the\n    // operation's exchange results\n    if ((this.activeOperations[operation.key] || 0) > 0) {\n      this.dispatchOperation(operation);\n    }\n  };\n\n  query<Data = any, Variables extends object = {}>(\n    query: DocumentNode | string,\n    variables?: Variables,\n    context?: Partial<OperationContext>\n  ): PromisifiedSource<OperationResult<Data>> {\n    if (!context || typeof context.suspense !== 'boolean') {\n      context = { ...context, suspense: false };\n    }\n\n    return withPromise<OperationResult<Data>>(\n      this.executeQuery(createRequest(query, variables), context)\n    );\n  }\n\n  executeQuery = <Data = any>(\n    query: GraphQLRequest,\n    opts?: Partial<OperationContext>\n  ): Source<OperationResult<Data>> => {\n    const operation = this.createRequestOperation('query', query, opts);\n    const response$ = this.executeRequestOperation(operation);\n    const { pollInterval } = operation.context;\n\n    if (pollInterval) {\n      return pipe(\n        merge([fromValue(0), interval(pollInterval)]),\n        switchMap(() => response$)\n      );\n    }\n\n    return response$;\n  };\n\n  executeSubscription = (\n    query: GraphQLRequest,\n    opts?: Partial<OperationContext>\n  ): Source<OperationResult> => {\n    const operation = this.createRequestOperation('subscription', query, opts);\n    return this.executeRequestOperation(operation);\n  };\n\n  mutation<Data = any, Variables extends object = {}>(\n    query: DocumentNode | string,\n    variables?: Variables,\n    context?: Partial<OperationContext>\n  ): PromisifiedSource<OperationResult<Data>> {\n    return withPromise<OperationResult<Data>>(\n      this.executeMutation(createRequest(query, variables), context)\n    );\n  }\n\n  executeMutation = <Data = any>(\n    query: GraphQLRequest,\n    opts?: Partial<OperationContext>\n  ): Source<OperationResult<Data>> => {\n    const operation = this.createRequestOperation('mutation', query, opts);\n    return this.executeRequestOperation(operation);\n  };\n}\n"],"names":["const","shouldSkip","operationName","x","ssrExchange","params","data","isCached","operation","undefined","key","op","result","deserialized","extensions","error","CombinedError","networkError","Error","graphQLErrors","deserializeResult","serialized","map","serializeResult","ssr","ops$","isClient","client","suspense","sharedOps$","share","forwardedOps$","forward","filter","cachedOps$","tap","merge","restoreData","restore","_extends","extractData","initialState","query","formatDocument","addMetadata","cacheOutcome","cacheExchange","resultCache","Map","operationCache","Object","create","mapTypeNames","handleAfterMutation","afterMutation","handleAfterQuery","afterQuery","isOperationCached","requestPolicy","has","cachedResult","get","context","stale","reexecuteOperation","response","delete","pendingOperations","Set","add","collectTypesFromResponse","forEach","typeName","operations","clear","set","isSubscriptionOperation","subscriptionExchange","subscriptionResults$","mergeMap","teardown$","takeUntil","observableish","forwardSubscription","toString","print","variables","make","isComplete","sub","subscribe","next","makeResult","err","makeErrorResult","complete","unsubscribe","createSubscriptionSource","forward$","console","log","debugExchange","process","env","NODE_ENV","dedupExchange","inFlightKeys","filterIncomingOperation","isInFlight","afterOperationResult","fetchExchange","isOperationFetchable","fetchResults$","createFetchSource","node","kind","Kind","OPERATION_DEFINITION","name","abortController","AbortController","extraOptions","fetchOptions","definitions","find","value","body","JSON","stringify","method","headers","signal","executeFetch","then","abort","opts","fetch","res","status","redirect","statusText","json","catch","warn","fallbackExchangeIO","composeExchanges","exchanges","length","payload","reduceRight","exchange","defaultExchanges","createClient","Client","url","this","type","request","createOperationContext","activeOperations","dispatchOperation","createRequestOperation","response$","executeRequestOperation","pollInterval","switchMap","fromValue","interval","makeSubject","operations$","queuedOperations","isDispatching","push","queued","shift","nextOperation","results$","publish","onOperationStart","onOperationEnd","prevActive","operationResults$","take","onStart","result$","onEnd","toSuspenseSource","withPromise","executeQuery","createRequest","mutation","executeMutation"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"core.js","sources":["../../src/exchanges/ssr.ts","../../src/exchanges/cache.ts","../../src/exchanges/subscription.ts","../../src/exchanges/debug.ts","../../src/exchanges/dedup.ts","../../src/exchanges/fetch.ts","../../src/exchanges/fallback.ts","../../src/exchanges/compose.ts","../../src/exchanges/index.ts","../../src/client.ts"],"sourcesContent":["import { pipe, share, filter, merge, map, tap } from 'wonka';\nimport { Exchange, OperationResult, Operation } from '../types';\nimport { CombinedError } from '../utils';\n\nexport interface SerializedResult {\n  data?: any;\n  error?: {\n    networkError?: string;\n    graphQLErrors: string[];\n  };\n}\n\nexport interface SSRData {\n  [key: string]: SerializedResult;\n}\n\nexport interface SSRExchangeParams {\n  isClient?: boolean;\n  initialState?: SSRData;\n}\n\nexport interface SSRExchange extends Exchange {\n  /** Rehydrates cached data */\n  restoreData(data: SSRData): void;\n  /** Extracts cached data */\n  extractData(): SSRData;\n}\n\nconst shouldSkip = ({ operationName }: Operation) =>\n  operationName !== 'subscription' && operationName !== 'query';\n\n/** Serialize an OperationResult to plain JSON */\nconst serializeResult = ({\n  data,\n  error,\n}: OperationResult): SerializedResult => {\n  const result: SerializedResult = { data, error: undefined };\n  if (error !== undefined) {\n    result.error = {\n      networkError: '' + error.networkError,\n      graphQLErrors: error.graphQLErrors.map(x => '' + x),\n    };\n  }\n\n  return result;\n};\n\n/** Deserialize plain JSON to an OperationResult */\nconst deserializeResult = (\n  operation: Operation,\n  result: SerializedResult\n): OperationResult => {\n  const { error, data } = result;\n  const deserialized: OperationResult = {\n    operation,\n    data,\n    extensions: undefined,\n    error: undefined,\n  };\n  if (error !== undefined) {\n    deserialized.error = new CombinedError({\n      networkError: new Error(error.networkError),\n      graphQLErrors: error.graphQLErrors,\n    });\n  }\n\n  return deserialized;\n};\n\n/** The ssrExchange can be created to capture data during SSR and also to rehydrate it on the client */\nexport const ssrExchange = (params?: SSRExchangeParams): SSRExchange => {\n  const data: SSRData = {};\n\n  const isCached = (operation: Operation) => {\n    return !shouldSkip(operation) && data[operation.key] !== undefined;\n  };\n\n  // The SSR Exchange is a temporary cache that can populate results into data for suspense\n  // On the client it can be used to retrieve these temporary results from a rehydrated cache\n  const ssr: SSRExchange = ({ client, forward }) => ops$ => {\n    // params.isClient tells us whether we're on the client-side\n    // By default we assume that we're on the client if suspense-mode is disabled\n    const isClient =\n      params && typeof params.isClient === 'boolean'\n        ? !!params.isClient\n        : !client.suspense;\n\n    const sharedOps$ = share(ops$);\n\n    let forwardedOps$ = pipe(\n      sharedOps$,\n      filter(op => !isCached(op)),\n      forward\n    );\n\n    // NOTE: Since below we might delete the cached entry after accessing\n    // it once, cachedOps$ needs to be merged after forwardedOps$\n    let cachedOps$ = pipe(\n      sharedOps$,\n      filter(op => isCached(op)),\n      map(op => {\n        const serialized = data[op.key];\n        return deserializeResult(op, serialized);\n      })\n    );\n\n    if (!isClient) {\n      // On the server we cache results in the cache as they're resolved\n      forwardedOps$ = pipe(\n        forwardedOps$,\n        tap((result: OperationResult) => {\n          const { operation } = result;\n          if (!shouldSkip(operation)) {\n            const serialized = serializeResult(result);\n            data[operation.key] = serialized;\n          }\n        })\n      );\n    } else {\n      // On the client we delete results from the cache as they're resolved\n      cachedOps$ = pipe(\n        cachedOps$,\n        tap((result: OperationResult) => {\n          delete data[result.operation.key];\n        })\n      );\n    }\n\n    return merge([forwardedOps$, cachedOps$]);\n  };\n\n  ssr.restoreData = (restore: SSRData) => Object.assign(data, restore);\n  ssr.extractData = () => Object.assign({}, data);\n\n  if (params && params.initialState) {\n    ssr.restoreData(params.initialState);\n  }\n\n  return ssr;\n};\n","/* eslint-disable @typescript-eslint/no-use-before-define */\nimport { filter, map, merge, pipe, share, tap } from 'wonka';\n\nimport { Client } from '../client';\nimport { Exchange, Operation, OperationResult } from '../types';\nimport {\n  addMetadata,\n  collectTypesFromResponse,\n  formatDocument,\n} from '../utils';\n\ntype ResultCache = Map<number, OperationResult>;\n\ninterface OperationCache {\n  [key: string]: Set<number>;\n}\n\nconst shouldSkip = ({ operationName }: Operation) =>\n  operationName !== 'mutation' && operationName !== 'query';\n\nexport const cacheExchange: Exchange = ({ forward, client }) => {\n  const resultCache = new Map() as ResultCache;\n  const operationCache = Object.create(null) as OperationCache;\n\n  // Adds unique typenames to query (for invalidating cache entries)\n  const mapTypeNames = (operation: Operation): Operation => ({\n    ...operation,\n    query: formatDocument(operation.query),\n  });\n\n  const handleAfterMutation = afterMutation(\n    resultCache,\n    operationCache,\n    client\n  );\n\n  const handleAfterQuery = afterQuery(resultCache, operationCache);\n\n  const isOperationCached = operation => {\n    const {\n      key,\n      operationName,\n      context: { requestPolicy },\n    } = operation;\n    return (\n      operationName === 'query' &&\n      requestPolicy !== 'network-only' &&\n      (requestPolicy === 'cache-only' || resultCache.has(key))\n    );\n  };\n\n  return ops$ => {\n    const sharedOps$ = share(ops$);\n\n    const cachedOps$ = pipe(\n      sharedOps$,\n      filter(op => !shouldSkip(op) && isOperationCached(op)),\n      map(operation => {\n        const cachedResult = resultCache.get(operation.key);\n        const result: OperationResult = {\n          ...cachedResult,\n          operation: addMetadata(operation, {\n            cacheOutcome: cachedResult ? 'hit' : 'miss',\n          }),\n        };\n\n        if (operation.context.requestPolicy === 'cache-and-network') {\n          result.stale = true;\n          reexecuteOperation(client, operation);\n        }\n\n        return result;\n      })\n    );\n\n    const forwardedOps$ = pipe(\n      merge([\n        pipe(\n          sharedOps$,\n          filter(op => !shouldSkip(op) && !isOperationCached(op)),\n          map(mapTypeNames)\n        ),\n        pipe(\n          sharedOps$,\n          filter(op => shouldSkip(op))\n        ),\n      ]),\n      map(op => addMetadata(op, { cacheOutcome: 'miss' })),\n      forward,\n      tap(response => {\n        if (\n          response.operation &&\n          response.operation.operationName === 'mutation'\n        ) {\n          handleAfterMutation(response);\n        } else if (\n          response.operation &&\n          response.operation.operationName === 'query'\n        ) {\n          handleAfterQuery(response);\n        }\n      })\n    );\n\n    return merge([cachedOps$, forwardedOps$]);\n  };\n};\n\n// Reexecutes a given operation with the default requestPolicy\nconst reexecuteOperation = (client: Client, operation: Operation) => {\n  return client.reexecuteOperation({\n    ...operation,\n    context: {\n      ...operation.context,\n      requestPolicy: 'network-only',\n    },\n  });\n};\n\n// Invalidates the cache given a mutation's response\nexport const afterMutation = (\n  resultCache: ResultCache,\n  operationCache: OperationCache,\n  client: Client\n) => (response: OperationResult) => {\n  const pendingOperations = new Set<number>();\n\n  collectTypesFromResponse(response.data).forEach(typeName => {\n    const operations =\n      operationCache[typeName] || (operationCache[typeName] = new Set());\n    operations.forEach(key => {\n      pendingOperations.add(key);\n    });\n    operations.clear();\n  });\n\n  pendingOperations.forEach(key => {\n    if (resultCache.has(key)) {\n      const operation = (resultCache.get(key) as OperationResult).operation;\n      resultCache.delete(key);\n      reexecuteOperation(client, operation);\n    }\n  });\n};\n\n// Mark typenames on typenameInvalidate for early invalidation\nconst afterQuery = (\n  resultCache: ResultCache,\n  operationCache: OperationCache\n) => (response: OperationResult) => {\n  const { operation, data, error } = response;\n\n  if (data === undefined || data === null) {\n    return;\n  }\n\n  resultCache.set(operation.key, { operation, data, error });\n\n  collectTypesFromResponse(response.data).forEach(typeName => {\n    const operations =\n      operationCache[typeName] || (operationCache[typeName] = new Set());\n    operations.add(operation.key);\n  });\n};\n","import { print } from 'graphql';\n\nimport {\n  filter,\n  make,\n  merge,\n  mergeMap,\n  pipe,\n  share,\n  Source,\n  takeUntil,\n} from 'wonka';\n\nimport { makeResult, makeErrorResult } from '../utils';\n\nimport {\n  Exchange,\n  ExecutionResult,\n  Operation,\n  OperationContext,\n  OperationResult,\n} from '../types';\n\nexport interface ObserverLike<T> {\n  next: (value: T) => void;\n  error: (err: any) => void;\n  complete: () => void;\n}\n\n/** An abstract observable interface conforming to: https://github.com/tc39/proposal-observable */\nexport interface ObservableLike<T> {\n  subscribe(\n    observer: ObserverLike<T>\n  ): {\n    unsubscribe: () => void;\n  };\n}\n\nexport interface SubscriptionOperation {\n  query: string;\n  variables?: object;\n  key: string;\n  context: OperationContext;\n}\n\nexport type SubscriptionForwarder = (\n  operation: SubscriptionOperation\n) => ObservableLike<ExecutionResult & { extensions?: Record<string, any> }>;\n\n/** This is called to create a subscription and needs to be hooked up to a transport client. */\nexport interface SubscriptionExchangeOpts {\n  // This has been modelled to work with subscription-transport-ws\n  // See: https://github.com/apollographql/subscriptions-transport-ws#requestoptions--observableexecutionresult-returns-observable-to-execute-the-operation\n  forwardSubscription: SubscriptionForwarder;\n}\n\nconst isSubscriptionOperation = (operation: Operation) =>\n  operation.operationName === 'subscription';\n\nexport const subscriptionExchange = ({\n  forwardSubscription,\n}: SubscriptionExchangeOpts): Exchange => ({ client, forward }) => {\n  const createSubscriptionSource = (\n    operation: Operation\n  ): Source<OperationResult> => {\n    // This excludes the query's name as a field although subscription-transport-ws does accept it since it's optional\n    const observableish = forwardSubscription({\n      key: operation.key.toString(36),\n      query: print(operation.query),\n      variables: operation.variables,\n      context: { ...operation.context },\n    });\n\n    return make<OperationResult>(({ next, complete }) => {\n      let isComplete = false;\n\n      const sub = observableish.subscribe({\n        next: result => next(makeResult(operation, result)),\n        error: err => next(makeErrorResult(operation, err)),\n        complete: () => {\n          if (!isComplete) {\n            isComplete = true;\n            client.reexecuteOperation({\n              ...operation,\n              operationName: 'teardown',\n            });\n\n            complete();\n          }\n        },\n      });\n\n      return () => {\n        isComplete = true;\n        sub.unsubscribe();\n      };\n    });\n  };\n\n  return ops$ => {\n    const sharedOps$ = share(ops$);\n    const subscriptionResults$ = pipe(\n      sharedOps$,\n      filter(isSubscriptionOperation),\n      mergeMap(operation => {\n        const { key } = operation;\n        const teardown$ = pipe(\n          sharedOps$,\n          filter(op => op.operationName === 'teardown' && op.key === key)\n        );\n\n        return pipe(createSubscriptionSource(operation), takeUntil(teardown$));\n      })\n    );\n\n    const forward$ = pipe(\n      sharedOps$,\n      filter(op => !isSubscriptionOperation(op)),\n      forward\n    );\n\n    return merge([subscriptionResults$, forward$]);\n  };\n};\n","import { pipe, tap } from 'wonka';\nimport { Exchange } from '../types';\n\nexport const debugExchange: Exchange = ({ forward }) => {\n  if (process.env.NODE_ENV === 'production') {\n    return ops$ => forward(ops$);\n  } else {\n    return ops$ =>\n      pipe(\n        ops$,\n        // eslint-disable-next-line no-console\n        tap(op => console.log('[Exchange debug]: Incoming operation: ', op)),\n        forward,\n        tap(result =>\n          // eslint-disable-next-line no-console\n          console.log('[Exchange debug]: Completed operation: ', result)\n        )\n      );\n  }\n};\n","import { filter, pipe, tap } from 'wonka';\nimport { Exchange, Operation, OperationResult } from '../types';\n\n/** A default exchange for debouncing GraphQL requests. */\nexport const dedupExchange: Exchange = ({ forward }) => {\n  const inFlightKeys = new Set<number>();\n\n  const filterIncomingOperation = (operation: Operation) => {\n    const { key, operationName } = operation;\n    if (operationName === 'teardown') {\n      inFlightKeys.delete(key);\n      return true;\n    } else if (operationName !== 'query' && operationName !== 'subscription') {\n      return true;\n    }\n\n    const isInFlight = inFlightKeys.has(key);\n    inFlightKeys.add(key);\n    return !isInFlight;\n  };\n\n  const afterOperationResult = ({ operation }: OperationResult) => {\n    inFlightKeys.delete(operation.key);\n  };\n\n  return ops$ => {\n    const forward$ = pipe(ops$, filter(filterIncomingOperation));\n    return pipe(forward(forward$), tap(afterOperationResult));\n  };\n};\n","/* eslint-disable @typescript-eslint/no-use-before-define */\nimport { Kind, DocumentNode, OperationDefinitionNode, print } from 'graphql';\nimport { filter, make, merge, mergeMap, pipe, share, takeUntil } from 'wonka';\nimport { Exchange, Operation, OperationResult } from '../types';\nimport { makeResult, makeErrorResult } from '../utils';\n\ninterface Body {\n  query: string;\n  variables: void | object;\n  operationName?: string;\n}\n\n/** A default exchange for fetching GraphQL requests. */\nexport const fetchExchange: Exchange = ({ forward }) => {\n  const isOperationFetchable = (operation: Operation) => {\n    const { operationName } = operation;\n    return operationName === 'query' || operationName === 'mutation';\n  };\n\n  return ops$ => {\n    const sharedOps$ = share(ops$);\n    const fetchResults$ = pipe(\n      sharedOps$,\n      filter(isOperationFetchable),\n      mergeMap(operation => {\n        const { key } = operation;\n        const teardown$ = pipe(\n          sharedOps$,\n          filter(op => op.operationName === 'teardown' && op.key === key)\n        );\n\n        return pipe(createFetchSource(operation), takeUntil(teardown$));\n      })\n    );\n\n    const forward$ = pipe(\n      sharedOps$,\n      filter(op => !isOperationFetchable(op)),\n      forward\n    );\n\n    return merge([fetchResults$, forward$]);\n  };\n};\n\nconst getOperationName = (query: DocumentNode): string | null => {\n  const node = query.definitions.find(\n    (node: any): node is OperationDefinitionNode => {\n      return node.kind === Kind.OPERATION_DEFINITION && node.name;\n    }\n  );\n\n  return node !== undefined && node.name ? node.name.value : null;\n};\n\nconst createFetchSource = (operation: Operation) => {\n  if (\n    process.env.NODE_ENV !== 'production' &&\n    operation.operationName === 'subscription'\n  ) {\n    throw new Error(\n      'Received a subscription operation in the httpExchange. You are probably trying to create a subscription. Have you added a subscriptionExchange?'\n    );\n  }\n\n  return make<OperationResult>(({ next, complete }) => {\n    const abortController =\n      typeof AbortController !== 'undefined'\n        ? new AbortController()\n        : undefined;\n\n    const { context } = operation;\n\n    const extraOptions =\n      typeof context.fetchOptions === 'function'\n        ? context.fetchOptions()\n        : context.fetchOptions || {};\n\n    const operationName = getOperationName(operation.query);\n\n    const body: Body = {\n      query: print(operation.query),\n      variables: operation.variables,\n    };\n\n    if (operationName !== null) {\n      body.operationName = operationName;\n    }\n\n    const fetchOptions = {\n      body: JSON.stringify(body),\n      method: 'POST',\n      ...extraOptions,\n      headers: {\n        'content-type': 'application/json',\n        ...extraOptions.headers,\n      },\n      signal:\n        abortController !== undefined ? abortController.signal : undefined,\n    };\n\n    let ended = false;\n\n    Promise.resolve()\n      .then(() => (ended ? undefined : executeFetch(operation, fetchOptions)))\n      .then((result: OperationResult | undefined) => {\n        if (!ended) {\n          ended = true;\n          if (result) next(result);\n          complete();\n        }\n      });\n\n    return () => {\n      ended = true;\n      if (abortController !== undefined) {\n        abortController.abort();\n      }\n    };\n  });\n};\n\nconst executeFetch = (\n  operation: Operation,\n  opts: RequestInit\n): Promise<OperationResult> => {\n  const { url, fetch: fetcher } = operation.context;\n  let response: Response | undefined;\n\n  return (fetcher || fetch)(url, opts)\n    .then(res => {\n      const { status } = res;\n      const statusRangeEnd = opts.redirect === 'manual' ? 400 : 300;\n      response = res;\n\n      if (status < 200 || status >= statusRangeEnd) {\n        throw new Error(res.statusText);\n      } else {\n        return res.json();\n      }\n    })\n    .then(result => makeResult(operation, result, response))\n    .catch(err => {\n      if (err.name !== 'AbortError') {\n        return makeErrorResult(operation, err, response);\n      }\n    });\n};\n","import { filter, pipe, tap } from 'wonka';\nimport { ExchangeIO, Operation } from '../types';\n\n/** This is always the last exchange in the chain; No operation should ever reach it */\nexport const fallbackExchangeIO: ExchangeIO = ops$ =>\n  pipe(\n    ops$,\n    tap<Operation>(({ operationName }) => {\n      if (\n        operationName !== 'teardown' &&\n        process.env.NODE_ENV !== 'production'\n      ) {\n        console.warn(\n          `No exchange has handled operations of type \"${operationName}\". Check whether you've added an exchange responsible for these operations.`\n        );\n      }\n    }),\n    /* All operations that skipped through the entire exchange chain should be filtered from the output */\n    filter<any>(() => false)\n  );\n","import { Exchange } from '../types';\n\n/** This composes an array of Exchanges into a single ExchangeIO function */\nexport const composeExchanges = (exchanges: Exchange[]): Exchange => {\n  if (exchanges.length === 1) {\n    return exchanges[0];\n  }\n\n  return payload => {\n    return exchanges.reduceRight((forward, exchange) => {\n      return exchange({ client: payload.client, forward });\n    }, payload.forward);\n  };\n};\n","export { ssrExchange } from './ssr';\nexport { cacheExchange } from './cache';\nexport { subscriptionExchange } from './subscription';\nexport { debugExchange } from './debug';\nexport { dedupExchange } from './dedup';\nexport { fetchExchange } from './fetch';\nexport { fallbackExchangeIO } from './fallback';\nexport { composeExchanges } from './compose';\n\nimport { cacheExchange } from './cache';\nimport { dedupExchange } from './dedup';\nimport { fetchExchange } from './fetch';\n\nexport const defaultExchanges = [dedupExchange, cacheExchange, fetchExchange];\n","// This is the entrypoint for the urql/client bundle.\n// It'll be output to dist/es/core.js and dist/cjs/core.js\n// This file also contains the main urql Client\nexport * from './exchanges';\nexport * from './types';\n\nexport {\n  CombinedError,\n  stringifyVariables,\n  createRequest,\n  makeResult,\n  makeErrorResult,\n  formatDocument,\n} from './utils';\n\n/* eslint-disable @typescript-eslint/no-use-before-define */\nimport {\n  filter,\n  makeSubject,\n  onEnd,\n  onStart,\n  pipe,\n  share,\n  Source,\n  take,\n  takeUntil,\n  merge,\n  interval,\n  fromValue,\n  switchMap,\n  publish,\n} from 'wonka';\n\nimport {\n  composeExchanges,\n  defaultExchanges,\n  fallbackExchangeIO,\n} from './exchanges';\n\nimport {\n  Exchange,\n  GraphQLRequest,\n  Operation,\n  OperationContext,\n  OperationResult,\n  OperationType,\n  RequestPolicy,\n  PromisifiedSource,\n} from './types';\n\nimport { createRequest, toSuspenseSource, withPromise } from './utils';\nimport { DocumentNode } from 'graphql';\n\n/** Options for configuring the URQL [client]{@link Client}. */\nexport interface ClientOptions {\n  /** Target endpoint URL such as `https://my-target:8080/graphql`. */\n  url: string;\n  /** Any additional options to pass to fetch. */\n  fetchOptions?: RequestInit | (() => RequestInit);\n  /** An alternative fetch implementation. */\n  fetch?: typeof fetch;\n  /** An ordered array of Exchanges. */\n  exchanges?: Exchange[];\n  /** Activates support for Suspense. */\n  suspense?: boolean;\n  /** The default request policy for requests. */\n  requestPolicy?: RequestPolicy;\n}\n\ninterface ActiveOperations {\n  [operationKey: string]: number;\n}\n\nexport const createClient = (opts: ClientOptions) => new Client(opts);\n\n/** The URQL application-wide client library. Each execute method starts a GraphQL request and returns a stream of results. */\nexport class Client {\n  // These are variables derived from ClientOptions\n  url: string;\n  fetch?: typeof fetch;\n  fetchOptions?: RequestInit | (() => RequestInit);\n  exchange: Exchange;\n  suspense: boolean;\n  requestPolicy: RequestPolicy;\n\n  // These are internals to be used to keep track of operations\n  dispatchOperation: (operation: Operation) => void;\n  operations$: Source<Operation>;\n  results$: Source<OperationResult>;\n  activeOperations = Object.create(null) as ActiveOperations;\n\n  constructor(opts: ClientOptions) {\n    this.url = opts.url;\n    this.fetchOptions = opts.fetchOptions;\n    this.fetch = opts.fetch;\n    this.suspense = !!opts.suspense;\n    this.requestPolicy = opts.requestPolicy || 'cache-first';\n\n    // This subject forms the input of operations; executeOperation may be\n    // called to dispatch a new operation on the subject\n    const { source: operations$, next: nextOperation } = makeSubject<\n      Operation\n    >();\n    this.operations$ = operations$;\n\n    // Internally operations aren't always dispatched immediately\n    // Since exchanges can dispatch and reexecute operations themselves,\n    // if we're inside an exchange we instead queue the operation and flush\n    // them in order after\n    const queuedOperations: Operation[] = [];\n    let isDispatching = false;\n\n    this.dispatchOperation = (operation: Operation) => {\n      queuedOperations.push(operation);\n      if (!isDispatching) {\n        isDispatching = true;\n        let queued;\n        while ((queued = queuedOperations.shift()) !== undefined)\n          nextOperation(queued);\n        isDispatching = false;\n      }\n    };\n\n    const exchanges =\n      opts.exchanges !== undefined ? opts.exchanges : defaultExchanges;\n\n    // All exchange are composed into a single one and are called using the constructed client\n    // and the fallback exchange stream\n    this.exchange = composeExchanges(exchanges);\n\n    // All operations run through the exchanges in a pipeline-like fashion\n    // and this observable then combines all their results\n    this.results$ = share(\n      this.exchange({\n        client: this,\n        forward: fallbackExchangeIO,\n      })(this.operations$)\n    );\n\n    // Prevent the `results$` exchange pipeline from being closed by active\n    // cancellations cascading up from components\n    pipe(this.results$, publish);\n  }\n\n  private createOperationContext = (\n    opts?: Partial<OperationContext>\n  ): OperationContext => ({\n    url: this.url,\n    fetchOptions: this.fetchOptions,\n    fetch: this.fetch,\n    ...opts,\n    requestPolicy: (opts || {}).requestPolicy || this.requestPolicy,\n  });\n\n  createRequestOperation = (\n    type: OperationType,\n    request: GraphQLRequest,\n    opts?: Partial<OperationContext>\n  ): Operation => ({\n    key: request.key,\n    query: request.query,\n    variables: request.variables,\n    operationName: type,\n    context: this.createOperationContext(opts),\n  });\n\n  /** Counts up the active operation key and dispatches the operation */\n  private onOperationStart(operation: Operation) {\n    const { key } = operation;\n    this.activeOperations[key] = (this.activeOperations[key] || 0) + 1;\n    this.dispatchOperation(operation);\n  }\n\n  /** Deletes an active operation's result observable and sends a teardown signal through the exchange pipeline */\n  private onOperationEnd(operation: Operation) {\n    const { key } = operation;\n    const prevActive = this.activeOperations[key] || 0;\n    const newActive = (this.activeOperations[key] =\n      prevActive <= 0 ? 0 : prevActive - 1);\n\n    if (newActive <= 0) {\n      this.dispatchOperation({ ...operation, operationName: 'teardown' });\n    }\n  }\n\n  /** Executes an Operation by sending it through the exchange pipeline It returns an observable that emits all related exchange results and keeps track of this observable's subscribers. A teardown signal will be emitted when no subscribers are listening anymore. */\n  executeRequestOperation(operation: Operation): Source<OperationResult> {\n    const { key, operationName } = operation;\n    const operationResults$ = pipe(\n      this.results$,\n      filter((res: OperationResult) => res.operation.key === key)\n    );\n\n    if (operationName === 'mutation') {\n      // A mutation is always limited to just a single result and is never shared\n      return pipe(\n        operationResults$,\n        onStart<OperationResult>(() => this.dispatchOperation(operation)),\n        take(1)\n      );\n    }\n\n    const teardown$ = pipe(\n      this.operations$,\n      filter(\n        (op: Operation) => op.operationName === 'teardown' && op.key === key\n      )\n    );\n\n    const result$ = pipe(\n      operationResults$,\n      takeUntil(teardown$),\n      onStart<OperationResult>(() => {\n        this.onOperationStart(operation);\n      }),\n      onEnd<OperationResult>(() => {\n        this.onOperationEnd(operation);\n      })\n    );\n\n    return operation.context.suspense !== false &&\n      this.suspense &&\n      operationName === 'query'\n      ? toSuspenseSource<OperationResult>(result$ as Source<OperationResult>)\n      : (result$ as Source<OperationResult>);\n  }\n\n  reexecuteOperation = (operation: Operation) => {\n    // Reexecute operation only if any subscribers are still subscribed to the\n    // operation's exchange results\n    if ((this.activeOperations[operation.key] || 0) > 0) {\n      this.dispatchOperation(operation);\n    }\n  };\n\n  query<Data = any, Variables extends object = {}>(\n    query: DocumentNode | string,\n    variables?: Variables,\n    context?: Partial<OperationContext>\n  ): PromisifiedSource<OperationResult<Data>> {\n    if (!context || typeof context.suspense !== 'boolean') {\n      context = { ...context, suspense: false };\n    }\n\n    return withPromise<OperationResult<Data>>(\n      this.executeQuery(createRequest(query, variables), context)\n    );\n  }\n\n  executeQuery = <Data = any>(\n    query: GraphQLRequest,\n    opts?: Partial<OperationContext>\n  ): Source<OperationResult<Data>> => {\n    const operation = this.createRequestOperation('query', query, opts);\n    const response$ = this.executeRequestOperation(operation);\n    const { pollInterval } = operation.context;\n\n    if (pollInterval) {\n      return pipe(\n        merge([fromValue(0), interval(pollInterval)]),\n        switchMap(() => response$)\n      );\n    }\n\n    return response$;\n  };\n\n  executeSubscription = (\n    query: GraphQLRequest,\n    opts?: Partial<OperationContext>\n  ): Source<OperationResult> => {\n    const operation = this.createRequestOperation('subscription', query, opts);\n    return this.executeRequestOperation(operation);\n  };\n\n  mutation<Data = any, Variables extends object = {}>(\n    query: DocumentNode | string,\n    variables?: Variables,\n    context?: Partial<OperationContext>\n  ): PromisifiedSource<OperationResult<Data>> {\n    return withPromise<OperationResult<Data>>(\n      this.executeMutation(createRequest(query, variables), context)\n    );\n  }\n\n  executeMutation = <Data = any>(\n    query: GraphQLRequest,\n    opts?: Partial<OperationContext>\n  ): Source<OperationResult<Data>> => {\n    const operation = this.createRequestOperation('mutation', query, opts);\n    return this.executeRequestOperation(operation);\n  };\n}\n"],"names":["const","shouldSkip","operationName","x","ssrExchange","params","data","isCached","operation","undefined","key","op","result","deserialized","extensions","error","CombinedError","networkError","Error","graphQLErrors","deserializeResult","serialized","map","serializeResult","ssr","ops$","isClient","client","suspense","sharedOps$","share","forwardedOps$","forward","filter","cachedOps$","tap","merge","restoreData","restore","_extends","extractData","initialState","query","formatDocument","addMetadata","cacheOutcome","cacheExchange","resultCache","Map","operationCache","Object","create","mapTypeNames","handleAfterMutation","afterMutation","handleAfterQuery","afterQuery","isOperationCached","requestPolicy","has","cachedResult","get","context","stale","reexecuteOperation","response","delete","pendingOperations","Set","add","collectTypesFromResponse","forEach","typeName","operations","clear","set","isSubscriptionOperation","subscriptionExchange","subscriptionResults$","mergeMap","teardown$","takeUntil","observableish","forwardSubscription","toString","print","variables","make","isComplete","sub","subscribe","next","makeResult","err","makeErrorResult","complete","unsubscribe","createSubscriptionSource","forward$","console","log","debugExchange","process","env","NODE_ENV","dedupExchange","inFlightKeys","filterIncomingOperation","isInFlight","afterOperationResult","fetchExchange","isOperationFetchable","fetchResults$","createFetchSource","node","kind","Kind","OPERATION_DEFINITION","name","abortController","AbortController","extraOptions","fetchOptions","definitions","find","value","body","JSON","stringify","method","headers","signal","ended","Promise","resolve","then","executeFetch","abort","opts","fetch","res","status","redirect","statusText","json","catch","warn","fallbackExchangeIO","composeExchanges","exchanges","length","payload","reduceRight","exchange","defaultExchanges","createClient","Client","url","this","type","request","createOperationContext","activeOperations","dispatchOperation","createRequestOperation","response$","executeRequestOperation","pollInterval","switchMap","fromValue","interval","makeSubject","operations$","queuedOperations","isDispatching","push","queued","shift","nextOperation","results$","publish","onOperationStart","onOperationEnd","prevActive","operationResults$","take","onStart","result$","onEnd","toSuspenseSource","withPromise","executeQuery","createRequest","mutation","executeMutation"],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/urql/dist/es/min/core.js b/node_modules/urql/dist/es/min/core.js
index bbda699..5836f75 100644
--- a/node_modules/urql/dist/es/min/core.js
+++ b/node_modules/urql/dist/es/min/core.js
@@ -1 +1 @@
-import{_ as t,C as e,a as r,f as n,c as o,m as i,b as a,t as u,w as c,d as p}from"./index-9bb95fa6.js";export{C as CombinedError,d as createRequest,f as formatDocument,b as makeErrorResult,m as makeResult,s as stringifyVariables}from"./index-9bb95fa6.js";import{share as h,filter as v,map as l,tap as y,merge as O,mergeMap as x,takeUntil as q,make as w,switchMap as k,fromValue as E,interval as N,makeSubject as g,publish as R,take as S,onStart as P,onEnd as j}from"wonka";import{print as Q,Kind as $}from"graphql";var D=function(t){var e=t.operationName;return"subscription"!==e&&"query"!==e};function I(t){return""+t}var A=function(r){var n={},o=function(t){return!D(t)&&void 0!==n[t.key]};function i(t){return!o(t)}function a(t){var r,o,i;return i={operation:t,data:(r=n[t.key]).data,extensions:void 0,error:void 0},void 0!==(o=r.error)&&(i.error=new e({networkError:new Error(o.networkError),graphQLErrors:o.graphQLErrors})),i}function u(t){return o(t)}function c(t){var e=t.operation;if(!D(e)){var r=function(t){var e=t.error,r={data:t.data,error:void 0};return void 0!==e&&(r.error={networkError:""+e.networkError,graphQLErrors:e.graphQLErrors.map(I)}),r}(t);n[e.key]=r}}function s(t){delete n[t.operation.key]}var f=function(t){var e=t.client,n=t.forward;return function(t){var o=r&&"boolean"==typeof r.isClient?!!r.isClient:!e.suspense,f=h(t),p=n(v(i)(f)),d=l(a)(v(u)(f));return o?d=y(s)(d):p=y(c)(p),O([p,d])}};return f.restoreData=function(e){return t(n,e)},f.extractData=function(){return t({},n)},r&&r.initialState&&f.restoreData(r.initialState),f},L=function(t){var e=t.operationName;return"mutation"!==e&&"query"!==e};function T(e){return t(t({},e),{query:n(e.query)})}function M(t){return r(t,{cacheOutcome:"miss"})}function _(t){return L(t)}var F=function(e){var n=e.forward,o=e.client,i=new Map,a=Object.create(null),u=T,c=V(i,a,o),s=z(i,a),f=function(t){var e=t.context.requestPolicy;return"query"===t.operationName&&"network-only"!==e&&("cache-only"===e||i.has(t.key))};function p(e){var n=i.get(e.key),a=t(t({},n),{operation:r(e,{cacheOutcome:n?"hit":"miss"})});return"cache-and-network"===e.context.requestPolicy&&(a.stale=!0,J(o,e)),a}function d(t){return!L(t)&&f(t)}function m(t){t.operation&&"mutation"===t.operation.operationName?c(t):t.operation&&"query"===t.operation.operationName&&s(t)}function x(t){return!L(t)&&!f(t)}return function(t){var e=h(t),r=l(p)(v(d)(e)),o=y(m)(n(l(M)(O([l(u)(v(x)(e)),v(_)(e)]))));return O([r,o])}},J=function(e,r){return e.reexecuteOperation(t(t({},r),{context:t(t({},r.context),{requestPolicy:"network-only"})}))},V=function(t,e,r){function n(e){if(t.has(e)){var n=t.get(e).operation;t.delete(e),J(r,n)}}return function(t){var r=new Set;function i(t){r.add(t)}o(t.data).forEach(function(t){var r=e[t]||(e[t]=new Set);r.forEach(i),r.clear()}),r.forEach(n)}},z=function(t,e){return function(r){var n=r.operation,i=r.data;null!=i&&(t.set(n.key,{operation:n,data:i,error:r.error}),o(r.data).forEach(function(t){(e[t]||(e[t]=new Set)).add(n.key)}))}},B=function(t){return"subscription"===t.operationName};function G(t){return!B(t)}var H=function(e){var r=e.forwardSubscription;return function(e){var n=e.client,o=e.forward;return function(e){var u=h(e),c=x(function(e){var o=e.key,c=v(function(t){return"teardown"===t.operationName&&t.key===o})(u);return q(c)(function(e){var o=r({key:e.key.toString(36),query:Q(e.query),variables:e.variables,context:t({},e.context)});return w(function(r){var u=r.next,c=r.complete,s=!1,f=o.subscribe({next:function(t){return u(i(e,t))},error:function(t){return u(a(e,t))},complete:function(){s||n.reexecuteOperation(t(t({},e),{operationName:"teardown"})),c()}});return function(){s=!0,f.unsubscribe()}})}(e))})(v(B)(u)),s=o(v(G)(u));return O([c,s])}}},K=function(t){var e=t.forward;return function(t){return e(t)}},U=function(t){var e=t.forward,r=new Set,n=function(t){var e=t.key,n=t.operationName;if("teardown"===n)return r.delete(e),!0;if("query"!==n&&"subscription"!==n)return!0;var o=r.has(e);return r.add(e),!o},o=function(t){r.delete(t.operation.key)};return function(t){var r=v(n)(t);return y(o)(e(r))}};function W(t){var e=t.operationName;return"query"===e||"mutation"===e}var X=function(t){var e=t.forward,r=W;function n(t){return!r(t)}return function(t){var o=h(t),i=x(function(t){var e=t.key,r=v(function(t){return"teardown"===t.operationName&&t.key===e})(o);return q(r)(Z(t))})(v(r)(o)),a=e(v(n)(o));return O([i,a])}};function Y(t){return t.kind===$.OPERATION_DEFINITION&&t.name}var Z=function(e){return w(function(r){var n,o=r.next,i=r.complete,a="undefined"!=typeof AbortController?new AbortController:void 0,u=e.context,c="function"==typeof u.fetchOptions?u.fetchOptions():u.fetchOptions||{},s=void 0!==(n=e.query.definitions.find(Y))&&n.name?n.name.value:null,f={query:Q(e.query),variables:e.variables};null!==s&&(f.operationName=s);var p=t(t({body:JSON.stringify(f),method:"POST"},c),{headers:t({"content-type":"application/json"},c.headers),signal:void 0!==a?a.signal:void 0});return tt(e,p).then(function(t){void 0!==t&&o(t),i()}),function(){void 0!==a&&a.abort()}})},tt=function(t,e){var r,n=t.context;return(n.fetch||fetch)(n.url,e).then(function(t){var n=t.status;if(r=t,n<200||n>=("manual"===e.redirect?400:300))throw new Error(t.statusText);return t.json()}).then(function(e){return i(t,e,r)}).catch(function(e){if("AbortError"!==e.name)return a(t,e,r)})};function et(){return!1}function rt(t){}var nt=function(t){return v(et)(y(rt)(t))},ot=function(t){return 1===t.length?t[0]:function(e){return t.reduceRight(function(t,r){return r({client:e.client,forward:t})},e.forward)}},it=[U,F,X],at=function(t){return new ut(t)},ut=function(e){var r=this;this.activeOperations=Object.create(null),this.createOperationContext=function(e){return t(t({url:r.url,fetchOptions:r.fetchOptions,fetch:r.fetch},e),{requestPolicy:(e||{}).requestPolicy||r.requestPolicy})},this.createRequestOperation=function(t,e,n){return{key:e.key,query:e.query,variables:e.variables,operationName:t,context:r.createOperationContext(n)}},this.reexecuteOperation=function(t){(r.activeOperations[t.key]||0)>0&&r.dispatchOperation(t)},this.executeQuery=function(t,e){var n=r.createRequestOperation("query",t,e),o=r.executeRequestOperation(n),i=n.context.pollInterval;return i?k(function(){return o})(O([E(0),N(i)])):o},this.executeSubscription=function(t,e){var n=r.createRequestOperation("subscription",t,e);return r.executeRequestOperation(n)},this.executeMutation=function(t,e){var n=r.createRequestOperation("mutation",t,e);return r.executeRequestOperation(n)},this.url=e.url,this.fetchOptions=e.fetchOptions,this.fetch=e.fetch,this.suspense=!!e.suspense,this.requestPolicy=e.requestPolicy||"cache-first";var n=g(),o=n.next;this.operations$=n.source;var i=[],a=!1;this.dispatchOperation=function(t){if(i.push(t),!a){var e;for(a=!0;void 0!==(e=i.shift());)o(e);a=!1}},this.exchange=ot(void 0!==e.exchanges?e.exchanges:it),this.results$=h(this.exchange({client:this,forward:nt})(this.operations$)),R(this.results$)};ut.prototype.onOperationStart=function(t){var e=t.key;this.activeOperations[e]=(this.activeOperations[e]||0)+1,this.dispatchOperation(t)},ut.prototype.onOperationEnd=function(e){var r=e.key,n=this.activeOperations[r]||0;(this.activeOperations[r]=n<=0?0:n-1)<=0&&this.dispatchOperation(t(t({},e),{operationName:"teardown"}))},ut.prototype.executeRequestOperation=function(t){var e=this,r=t.key,n=t.operationName,o=v(function(t){return t.operation.key===r})(this.results$);if("mutation"===n)return S(1)(P(function(){return e.dispatchOperation(t)})(o));var i=v(function(t){return"teardown"===t.operationName&&t.key===r})(this.operations$),a=j(function(){e.onOperationEnd(t)})(P(function(){e.onOperationStart(t)})(q(i)(o)));return!1!==t.context.suspense&&this.suspense&&"query"===n?u(a):a},ut.prototype.query=function(e,r,n){return n&&"boolean"==typeof n.suspense||(n=t(t({},n),{suspense:!1})),c(this.executeQuery(p(e,r),n))},ut.prototype.mutation=function(t,e,r){return c(this.executeMutation(p(t,e),r))};export{ut as Client,F as cacheExchange,ot as composeExchanges,at as createClient,K as debugExchange,U as dedupExchange,it as defaultExchanges,nt as fallbackExchangeIO,X as fetchExchange,A as ssrExchange,H as subscriptionExchange};
\ No newline at end of file
+import{_ as t,C as e,a as r,f as n,c as o,m as i,b as a,t as u,w as c,d as p}from"./index-9bb95fa6.js";export{C as CombinedError,d as createRequest,f as formatDocument,b as makeErrorResult,m as makeResult,s as stringifyVariables}from"./index-9bb95fa6.js";import{share as h,filter as v,map as l,tap as y,merge as O,mergeMap as x,takeUntil as q,make as w,switchMap as k,fromValue as E,interval as N,makeSubject as g,publish as R,take as S,onStart as P,onEnd as j}from"wonka";import{print as Q,Kind as $}from"graphql";var D=function(t){var e=t.operationName;return"subscription"!==e&&"query"!==e};function I(t){return""+t}var A=function(r){var n={},o=function(t){return!D(t)&&void 0!==n[t.key]};function i(t){return!o(t)}function a(t){var r,o,i;return i={operation:t,data:(r=n[t.key]).data,extensions:void 0,error:void 0},void 0!==(o=r.error)&&(i.error=new e({networkError:new Error(o.networkError),graphQLErrors:o.graphQLErrors})),i}function u(t){return o(t)}function c(t){var e=t.operation;if(!D(e)){var r=function(t){var e=t.error,r={data:t.data,error:void 0};return void 0!==e&&(r.error={networkError:""+e.networkError,graphQLErrors:e.graphQLErrors.map(I)}),r}(t);n[e.key]=r}}function s(t){delete n[t.operation.key]}var f=function(t){var e=t.client,n=t.forward;return function(t){var o=r&&"boolean"==typeof r.isClient?!!r.isClient:!e.suspense,f=h(t),p=n(v(i)(f)),d=l(a)(v(u)(f));return o?d=y(s)(d):p=y(c)(p),O([p,d])}};return f.restoreData=function(e){return t(n,e)},f.extractData=function(){return t({},n)},r&&r.initialState&&f.restoreData(r.initialState),f},L=function(t){var e=t.operationName;return"mutation"!==e&&"query"!==e};function T(e){return t(t({},e),{query:n(e.query)})}function M(t){return r(t,{cacheOutcome:"miss"})}function _(t){return L(t)}var F=function(e){var n=e.forward,o=e.client,i=new Map,a=Object.create(null),u=T,c=V(i,a,o),s=z(i,a),f=function(t){var e=t.context.requestPolicy;return"query"===t.operationName&&"network-only"!==e&&("cache-only"===e||i.has(t.key))};function p(e){var n=i.get(e.key),a=t(t({},n),{operation:r(e,{cacheOutcome:n?"hit":"miss"})});return"cache-and-network"===e.context.requestPolicy&&(a.stale=!0,J(o,e)),a}function d(t){return!L(t)&&f(t)}function m(t){t.operation&&"mutation"===t.operation.operationName?c(t):t.operation&&"query"===t.operation.operationName&&s(t)}function x(t){return!L(t)&&!f(t)}return function(t){var e=h(t),r=l(p)(v(d)(e)),o=y(m)(n(l(M)(O([l(u)(v(x)(e)),v(_)(e)]))));return O([r,o])}},J=function(e,r){return e.reexecuteOperation(t(t({},r),{context:t(t({},r.context),{requestPolicy:"network-only"})}))},V=function(t,e,r){function n(e){if(t.has(e)){var n=t.get(e).operation;t.delete(e),J(r,n)}}return function(t){var r=new Set;function i(t){r.add(t)}o(t.data).forEach(function(t){var r=e[t]||(e[t]=new Set);r.forEach(i),r.clear()}),r.forEach(n)}},z=function(t,e){return function(r){var n=r.operation,i=r.data;null!=i&&(t.set(n.key,{operation:n,data:i,error:r.error}),o(r.data).forEach(function(t){(e[t]||(e[t]=new Set)).add(n.key)}))}},B=function(t){return"subscription"===t.operationName};function G(t){return!B(t)}var H=function(e){var r=e.forwardSubscription;return function(e){var n=e.client,o=e.forward;return function(e){var u=h(e),c=x(function(e){var o=e.key,c=v(function(t){return"teardown"===t.operationName&&t.key===o})(u);return q(c)(function(e){var o=r({key:e.key.toString(36),query:Q(e.query),variables:e.variables,context:t({},e.context)});return w(function(r){var u=r.next,c=r.complete,s=!1,f=o.subscribe({next:function(t){return u(i(e,t))},error:function(t){return u(a(e,t))},complete:function(){s||(s=!0,n.reexecuteOperation(t(t({},e),{operationName:"teardown"})),c())}});return function(){s=!0,f.unsubscribe()}})}(e))})(v(B)(u)),s=o(v(G)(u));return O([c,s])}}},K=function(t){var e=t.forward;return function(t){return e(t)}},U=function(t){var e=t.forward,r=new Set,n=function(t){var e=t.key,n=t.operationName;if("teardown"===n)return r.delete(e),!0;if("query"!==n&&"subscription"!==n)return!0;var o=r.has(e);return r.add(e),!o},o=function(t){r.delete(t.operation.key)};return function(t){var r=v(n)(t);return y(o)(e(r))}};function W(t){var e=t.operationName;return"query"===e||"mutation"===e}var X=function(t){var e=t.forward,r=W;function n(t){return!r(t)}return function(t){var o=h(t),i=x(function(t){var e=t.key,r=v(function(t){return"teardown"===t.operationName&&t.key===e})(o);return q(r)(Z(t))})(v(r)(o)),a=e(v(n)(o));return O([i,a])}};function Y(t){return t.kind===$.OPERATION_DEFINITION&&t.name}var Z=function(e){return w(function(r){var n,o=r.next,i=r.complete,a="undefined"!=typeof AbortController?new AbortController:void 0,u=e.context,c="function"==typeof u.fetchOptions?u.fetchOptions():u.fetchOptions||{},s=void 0!==(n=e.query.definitions.find(Y))&&n.name?n.name.value:null,f={query:Q(e.query),variables:e.variables};null!==s&&(f.operationName=s);var p=t(t({body:JSON.stringify(f),method:"POST"},c),{headers:t({"content-type":"application/json"},c.headers),signal:void 0!==a?a.signal:void 0}),h=!1;return Promise.resolve().then(function(){return h?void 0:tt(e,p)}).then(function(t){h||(h=!0,t&&o(t),i())}),function(){h=!0,void 0!==a&&a.abort()}})},tt=function(t,e){var r,n=t.context;return(n.fetch||fetch)(n.url,e).then(function(t){var n=t.status;if(r=t,n<200||n>=("manual"===e.redirect?400:300))throw new Error(t.statusText);return t.json()}).then(function(e){return i(t,e,r)}).catch(function(e){if("AbortError"!==e.name)return a(t,e,r)})};function et(){return!1}function rt(t){}var nt=function(t){return v(et)(y(rt)(t))},ot=function(t){return 1===t.length?t[0]:function(e){return t.reduceRight(function(t,r){return r({client:e.client,forward:t})},e.forward)}},it=[U,F,X],at=function(t){return new ut(t)},ut=function(e){var r=this;this.activeOperations=Object.create(null),this.createOperationContext=function(e){return t(t({url:r.url,fetchOptions:r.fetchOptions,fetch:r.fetch},e),{requestPolicy:(e||{}).requestPolicy||r.requestPolicy})},this.createRequestOperation=function(t,e,n){return{key:e.key,query:e.query,variables:e.variables,operationName:t,context:r.createOperationContext(n)}},this.reexecuteOperation=function(t){(r.activeOperations[t.key]||0)>0&&r.dispatchOperation(t)},this.executeQuery=function(t,e){var n=r.createRequestOperation("query",t,e),o=r.executeRequestOperation(n),i=n.context.pollInterval;return i?k(function(){return o})(O([E(0),N(i)])):o},this.executeSubscription=function(t,e){var n=r.createRequestOperation("subscription",t,e);return r.executeRequestOperation(n)},this.executeMutation=function(t,e){var n=r.createRequestOperation("mutation",t,e);return r.executeRequestOperation(n)},this.url=e.url,this.fetchOptions=e.fetchOptions,this.fetch=e.fetch,this.suspense=!!e.suspense,this.requestPolicy=e.requestPolicy||"cache-first";var n=g(),o=n.next;this.operations$=n.source;var i=[],a=!1;this.dispatchOperation=function(t){if(i.push(t),!a){var e;for(a=!0;void 0!==(e=i.shift());)o(e);a=!1}},this.exchange=ot(void 0!==e.exchanges?e.exchanges:it),this.results$=h(this.exchange({client:this,forward:nt})(this.operations$)),R(this.results$)};ut.prototype.onOperationStart=function(t){var e=t.key;this.activeOperations[e]=(this.activeOperations[e]||0)+1,this.dispatchOperation(t)},ut.prototype.onOperationEnd=function(e){var r=e.key,n=this.activeOperations[r]||0;(this.activeOperations[r]=n<=0?0:n-1)<=0&&this.dispatchOperation(t(t({},e),{operationName:"teardown"}))},ut.prototype.executeRequestOperation=function(t){var e=this,r=t.key,n=t.operationName,o=v(function(t){return t.operation.key===r})(this.results$);if("mutation"===n)return S(1)(P(function(){return e.dispatchOperation(t)})(o));var i=v(function(t){return"teardown"===t.operationName&&t.key===r})(this.operations$),a=j(function(){e.onOperationEnd(t)})(P(function(){e.onOperationStart(t)})(q(i)(o)));return!1!==t.context.suspense&&this.suspense&&"query"===n?u(a):a},ut.prototype.query=function(e,r,n){return n&&"boolean"==typeof n.suspense||(n=t(t({},n),{suspense:!1})),c(this.executeQuery(p(e,r),n))},ut.prototype.mutation=function(t,e,r){return c(this.executeMutation(p(t,e),r))};export{ut as Client,F as cacheExchange,ot as composeExchanges,at as createClient,K as debugExchange,U as dedupExchange,it as defaultExchanges,nt as fallbackExchangeIO,X as fetchExchange,A as ssrExchange,H as subscriptionExchange};
\ No newline at end of file
diff --git a/node_modules/urql/dist/es/min/urql.js b/node_modules/urql/dist/es/min/urql.js
index fe56141..d8fb441 100644
--- a/node_modules/urql/dist/es/min/urql.js
+++ b/node_modules/urql/dist/es/min/urql.js
@@ -1 +1 @@
-import{_ as e,d as r}from"./index-9bb95fa6.js";export{C as CombinedError,d as createRequest,f as formatDocument,b as makeErrorResult,m as makeResult,s as stringifyVariables}from"./index-9bb95fa6.js";import{toPromise as t,scan as n,switchMap as a,fromValue as o,concat as u,map as c}from"wonka";import{createClient as i}from"./core.js";export{Client,cacheExchange,composeExchanges,createClient,debugExchange,dedupExchange,defaultExchanges,fallbackExchangeIO,fetchExchange,ssrExchange,subscriptionExchange}from"./core.js";import{createContext as l,useContext as x,useState as h,useCallback as v,useMemo as g,useRef as p}from"react";import{useOperator as y}from"react-wonka";var E=l(i({url:"/graphql"})),q=E.Provider,k=E.Consumer,j=function(){return x(E)},I={fetching:!1,stale:!1,error:void 0,data:void 0,extensions:void 0},P=function(n){var a=j(),o=h(I),u=o[1];function c(e){return u({fetching:!1,stale:!!e.stale,data:e.data,error:e.error,extensions:e.extensions}),e}return[o[0],v(function(o,i){u(e(e({},I),{fetching:!0}));var s=r(n,o);return t(a.executeMutation(s,i||{})).then(c)},[a,n,u])]},R=function(e,t){var n=p(void 0);return g(function(){var a=r(e,t);return void 0!==n.current&&n.current.key===a.key?n.current:(n.current=a,a)},[e,t])};function w(r,t){return e(e(e({},r),{stale:!1}),t)}function M(e){return{fetching:!1,stale:!!e.stale,data:e.data,error:e.error,extensions:e.extensions}}function Q(e){return e?u([o({fetching:!0}),c(M)(e),o({fetching:!1})]):o({fetching:!1})}function S(e){return n(w,I)(a(Q)(e))}var D=function(r){var t=j(),n=R(r.query,r.variables),a=v(function(a){return t.executeQuery(n,e(e({requestPolicy:r.requestPolicy,pollInterval:r.pollInterval},r.context),a))},[t,n,r.requestPolicy,r.pollInterval,r.context]),o=y(S,g(function(){return r.pause?null:a()},[r.pause,a]),I),u=o[1];return[o[0],v(function(e){return u(a(e))},[u,a])]};function O(e){return{fetching:!0,stale:!!e.stale,data:e.data,error:e.error,extensions:e.extensions}}function V(e){return e?u([o({fetching:!0}),c(O)(e),o({fetching:!1})]):o({fetching:!1})}var _=function(r,t){var o=j(),u=p(t);u.current=t;var c=R(r.query,r.variables),i=v(function(t){return o.executeSubscription(c,e(e({},r.context),t))},[o,c,r.context]);function s(r,t){var n=u.current,a=void 0!==t.data?"function"==typeof n?n(r.data,t.data):t.data:r.data;return e(e(e(e({},r),{stale:!1}),t),{data:a})}var f=y(function(e){return n(s,I)(a(V)(e))},g(function(){return r.pause?null:i()},[r.pause,i]),I),l=f[1];return[f[0],v(function(e){return l(i(e))},[l,i])]};function z(r){var t=P(r.query),n=t[1];return r.children(e(e({},t[0]),{executeMutation:n}))}function A(r){var t=D(r),n=t[1];return r.children(e(e({},t[0]),{executeQuery:n}))}function B(r){var t=_(r,r.handler),n=t[1];return r.children(e(e({},t[0]),{executeSubscription:n}))}export{k as Consumer,E as Context,z as Mutation,q as Provider,A as Query,B as Subscription,j as useClient,P as useMutation,D as useQuery,_ as useSubscription};
\ No newline at end of file
+import{_ as e,d as n}from"./index-9bb95fa6.js";export{C as CombinedError,d as createRequest,f as formatDocument,b as makeErrorResult,m as makeResult,s as stringifyVariables}from"./index-9bb95fa6.js";import{toPromise as r,onPush as t,publish as u,subscribe as a,makeSubject as o,map as c,fromValue as i,concat as l,scan as x,switchMap as h}from"wonka";import{createClient as v}from"./core.js";export{Client,cacheExchange,composeExchanges,createClient,debugExchange,dedupExchange,defaultExchanges,fallbackExchangeIO,fetchExchange,ssrExchange,subscriptionExchange}from"./core.js";import{createContext as p,useContext as g,useState as y,useCallback as E,useMemo as q,useEffect as k,useRef as j}from"react";import{useSubscription as I}from"use-subscription";var P=p(v({url:"/graphql"})),R=P.Provider,S=P.Consumer,M=function(){return g(P)},Q={fetching:!1,stale:!1,error:void 0,data:void 0,extensions:void 0},V=function(t){var u=M(),a=y(Q),o=a[1];function c(e){return o({fetching:!1,stale:!!e.stale,data:e.data,error:e.error,extensions:e.extensions}),e}return[a[0],E(function(a,i){o(e(e({},Q),{fetching:!0}));var s=n(t,a);return r(u.executeMutation(s,i||{})).then(c)},[u,t,o])]},w=function(e,n){return I(q(function(){var r=!1,o=n,c=t(function(e){o=e})(e);return{getCurrentValue:function(){return r||u(c).unsubscribe(),o},subscribe:function(e){return a(function(){r=!0,e(),r=!1})(c).unsubscribe}}},[e]))},D=function(e){var n=q(function(){var n=e,r=o(),t=c(function(){return n})(i(e));return[l([t,r.source]),function(e){r.next(n=e)}]},[]);return k(function(){n[1](e)},[n,e]),n},O=function(e,r){var t=j(void 0);return q(function(){var u=n(e,r);return void 0!==t.current&&t.current.key===u.key?t.current:(t.current=u,u)},[e,r])};function _(n,r){return e(e({},n),r)}function z(e){return{fetching:!1,stale:!!e.stale,data:e.data,error:e.error,extensions:e.extensions}}function A(e){return e?l([i({fetching:!0,stale:!1}),c(z)(e),i({fetching:!1,stale:!1})]):i({fetching:!1,stale:!1})}var B=function(n){var r=M(),t=O(n.query,n.variables),u=E(function(u){return r.executeQuery(t,e(e({requestPolicy:n.requestPolicy,pollInterval:n.pollInterval},n.context),u))},[r,t,n.requestPolicy,n.pollInterval,n.context]),a=D(q(function(){return n.pause?null:u()},[n.pause,u])),o=a[0],c=a[1];return[w(q(function(){return x(_,Q)(h(A)(o))},[o]),Q),E(function(e){return c(u(e))},[c,u])]};function F(e){return{fetching:!0,stale:!!e.stale,data:e.data,error:e.error,extensions:e.extensions}}function G(e){return e?l([i({fetching:!0,stale:!1}),c(F)(e),i({fetching:!1,stale:!1})]):i({fetching:!1})}var H=function(n,r){var t=M(),u=j(r);u.current=r;var a=O(n.query,n.variables),o=E(function(r){return t.executeSubscription(a,e(e({},n.context),r))},[t,a,n.context]),c=D(q(function(){return n.pause?null:o()},[n.pause,o])),i=c[0],s=c[1];function f(n,r){var t=u.current,a=void 0!==r.data?"function"==typeof t?t(n.data,r.data):r.data:n.data;return e(e(e({},n),r),{data:a})}return[w(q(function(){return x(f,Q)(h(G)(i))},[i]),Q),E(function(e){return s(o(e))},[s,o])]};function J(n){var r=V(n.query),t=r[1];return n.children(e(e({},r[0]),{executeMutation:t}))}function K(n){var r=B(n),t=r[1];return n.children(e(e({},r[0]),{executeQuery:t}))}function L(n){var r=H(n,n.handler),t=r[1];return n.children(e(e({},r[0]),{executeSubscription:t}))}export{S as Consumer,P as Context,J as Mutation,R as Provider,K as Query,L as Subscription,M as useClient,V as useMutation,B as useQuery,H as useSubscription};
\ No newline at end of file
diff --git a/node_modules/urql/dist/es/urql.js b/node_modules/urql/dist/es/urql.js
index 496b1e6..7e63e51 100644
--- a/node_modules/urql/dist/es/urql.js
+++ b/node_modules/urql/dist/es/urql.js
@@ -1,10 +1,10 @@
 import { _ as _extends, d as createRequest } from "./index-9bb95fa6.js";
 export { C as CombinedError, d as createRequest, f as formatDocument, b as makeErrorResult, m as makeResult, s as stringifyVariables } from "./index-9bb95fa6.js";
-import { toPromise, scan, switchMap, fromValue, concat, map } from "wonka";
+import { toPromise, onPush, publish, subscribe, makeSubject, map, fromValue, concat, scan, switchMap } from "wonka";
 import { createClient } from "./core.js";
 export { Client, cacheExchange, composeExchanges, createClient, debugExchange, dedupExchange, defaultExchanges, fallbackExchangeIO, fetchExchange, ssrExchange, subscriptionExchange } from "./core.js";
-import { createContext, useContext, useState, useCallback, useMemo, useRef } from "react";
-import { useOperator } from "react-wonka";
+import { createContext, useContext, useState, useCallback, useMemo, useEffect, useRef } from "react";
+import { useSubscription as useSubscription$1 } from "use-subscription";
 var defaultClient = createClient({
   url: "/graphql"
 });
@@ -57,6 +57,49 @@ var useMutation = function (query) {
   }, [client, query, setState])];
 };
 
+var useSource = function (source, init) {
+  return useSubscription$1(useMemo(function () {
+    var hasUpdate = !1;
+    var currentValue = init;
+    var updateValue = onPush(function (value) {
+      currentValue = value;
+    })(source);
+    return {
+      getCurrentValue: function getCurrentValue() {
+        if (!hasUpdate) {
+          publish(updateValue).unsubscribe();
+        }
+
+        return currentValue;
+      },
+      subscribe: function subscribe$1(onValue) {
+        return subscribe(function () {
+          hasUpdate = !0;
+          onValue();
+          hasUpdate = !1;
+        })(updateValue).unsubscribe;
+      }
+    };
+  }, [source]));
+};
+
+var useBehaviourSubject = function (value) {
+  var state = useMemo(function () {
+    var prevValue = value;
+    var subject = makeSubject();
+    var prevValue$ = map(function () {
+      return prevValue;
+    })(fromValue(value));
+    return [concat([prevValue$, subject.source]), function (value) {
+      subject.next(prevValue = value);
+    }];
+  }, []);
+  useEffect(function () {
+    state[1](value);
+  }, [state, value]);
+  return state;
+};
+
 var useRequest = function (query, variables) {
   var prev = useRef(void 0);
   return useMemo(function () {
@@ -72,9 +115,7 @@ var useRequest = function (query, variables) {
 };
 
 function _ref(result, partial) {
-  return _extends(_extends(_extends({}, result), {
-    stale: !1
-  }), partial);
+  return _extends(_extends({}, result), partial);
 }
 
 function _ref2(ref) {
@@ -90,21 +131,20 @@ function _ref2(ref) {
 function _ref3(query$) {
   if (!query$) {
     return fromValue({
-      fetching: !1
+      fetching: !1,
+      stale: !1
     });
   }
 
   return concat([fromValue({
-    fetching: !0
+    fetching: !0,
+    stale: !1
   }), map(_ref2)(query$), fromValue({
-    fetching: !1
+    fetching: !1,
+    stale: !1
   })]);
 }
 
-function _ref4(query$$) {
-  return scan(_ref, initialState)(switchMap(_ref3)(query$$));
-}
-
 var useQuery = function (args) {
   var client = useClient();
   var request = useRequest(args.query, args.variables);
@@ -114,11 +154,14 @@ var useQuery = function (args) {
       pollInterval: args.pollInterval
     }, args.context), opts));
   }, [client, request, args.requestPolicy, args.pollInterval, args.context]);
-  var ref = useOperator(_ref4, useMemo(function () {
+  var ref = useBehaviourSubject(useMemo(function () {
     return args.pause ? null : makeQuery$();
-  }, [args.pause, makeQuery$]), initialState);
+  }, [args.pause, makeQuery$]));
+  var query$$ = ref[0];
   var update = ref[1];
-  return [ref[0], useCallback(function (opts) {
+  return [useSource(useMemo(function () {
+    return scan(_ref, initialState)(switchMap(_ref3)(query$$));
+  }, [query$$]), initialState), useCallback(function (opts) {
     return update(makeQuery$(opts));
   }, [update, makeQuery$])];
 };
@@ -141,9 +184,11 @@ function _ref3$1(subscription$) {
   }
 
   return concat([fromValue({
-    fetching: !0
+    fetching: !0,
+    stale: !1
   }), map(_ref2$1)(subscription$), fromValue({
-    fetching: !1
+    fetching: !1,
+    stale: !1
   })]);
 }
 
@@ -155,24 +200,23 @@ var useSubscription = function (args, handler) {
   var makeSubscription$ = useCallback(function (opts) {
     return client.executeSubscription(request, _extends(_extends({}, args.context), opts));
   }, [client, request, args.context]);
+  var ref = useBehaviourSubject(useMemo(function () {
+    return args.pause ? null : makeSubscription$();
+  }, [args.pause, makeSubscription$]));
+  var subscription$$ = ref[0];
+  var update = ref[1];
 
   function _ref(result, partial) {
     var handler = handlerRef.current;
     var data = void 0 !== partial.data ? "function" == typeof handler ? handler(result.data, partial.data) : partial.data : result.data;
-    return _extends(_extends(_extends(_extends({}, result), {
-      stale: !1
-    }), partial), {
+    return _extends(_extends(_extends({}, result), partial), {
       data: data
     });
   }
 
-  var ref = useOperator(function (subscription$$) {
+  return [useSource(useMemo(function () {
     return scan(_ref, initialState)(switchMap(_ref3$1)(subscription$$));
-  }, useMemo(function () {
-    return args.pause ? null : makeSubscription$();
-  }, [args.pause, makeSubscription$]), initialState);
-  var update = ref[1];
-  return [ref[0], useCallback(function (opts) {
+  }, [subscription$$]), initialState), useCallback(function (opts) {
     return update(makeSubscription$(opts));
   }, [update, makeSubscription$])];
 };
diff --git a/node_modules/urql/dist/es/urql.js.map b/node_modules/urql/dist/es/urql.js.map
index 19770d0..22212d1 100644
--- a/node_modules/urql/dist/es/urql.js.map
+++ b/node_modules/urql/dist/es/urql.js.map
@@ -1 +1 @@
-{"version":3,"file":"urql.js","sources":["../../src/context.ts","../../src/hooks/constants.ts","../../src/hooks/useMutation.ts","../../src/hooks/useRequest.ts","../../src/hooks/useQuery.ts","../../src/hooks/useSubscription.ts","../../src/components/Mutation.ts","../../src/components/Query.ts","../../src/components/Subscription.ts"],"sourcesContent":["import { createContext, useContext } from 'react';\nimport { Client, createClient } from './client';\n\n// We assume some default options here; mainly not to actually be used\n// but not to error catastrophically if someone is just playing around\nconst defaultClient = createClient({ url: '/graphql' });\n\nexport const Context = createContext<Client>(defaultClient);\nexport const Provider = Context.Provider;\nexport const Consumer = Context.Consumer;\n\nlet hasWarnedAboutDefault = false;\n\nexport const useClient = (): Client => {\n  const client = useContext(Context);\n\n  if (\n    process.env.NODE_ENV !== 'production' &&\n    client === defaultClient &&\n    !hasWarnedAboutDefault\n  ) {\n    hasWarnedAboutDefault = true;\n\n    console.warn(\n      \"Default Client: No client has been specified using urql's Provider.\" +\n        'This means that urql will be falling back to defaults including making ' +\n        'requests to `/graphql`.\\n' +\n        \"If that's not what you want, please create a client and add a Provider.\"\n    );\n  }\n\n  return client;\n};\n","export const initialState = {\n  fetching: false,\n  stale: false,\n  error: undefined,\n  data: undefined,\n  extensions: undefined,\n};\n","import { DocumentNode } from 'graphql';\nimport { useState, useCallback } from 'react';\nimport { pipe, toPromise } from 'wonka';\nimport { useClient } from '../context';\nimport { OperationResult, OperationContext } from '../types';\nimport { CombinedError, createRequest } from '../utils';\nimport { initialState } from './constants';\n\nexport interface UseMutationState<T> {\n  fetching: boolean;\n  stale: boolean;\n  data?: T;\n  error?: CombinedError;\n  extensions?: Record<string, any>;\n}\n\nexport type UseMutationResponse<T, V> = [\n  UseMutationState<T>,\n  (\n    variables?: V,\n    context?: Partial<OperationContext>\n  ) => Promise<OperationResult<T>>\n];\n\nexport const useMutation = <T = any, V = object>(\n  query: DocumentNode | string\n): UseMutationResponse<T, V> => {\n  const client = useClient();\n\n  const [state, setState] = useState<UseMutationState<T>>(initialState);\n\n  const executeMutation = useCallback(\n    (variables?: V, context?: Partial<OperationContext>) => {\n      setState({ ...initialState, fetching: true });\n\n      const request = createRequest(query, variables as any);\n\n      return pipe(\n        client.executeMutation(request, context || {}),\n        toPromise\n      ).then(result => {\n        setState({\n          fetching: false,\n          stale: !!result.stale,\n          data: result.data,\n          error: result.error,\n          extensions: result.extensions,\n        });\n        return result;\n      });\n    },\n    [client, query, setState]\n  );\n\n  return [state, executeMutation];\n};\n","import { DocumentNode } from 'graphql';\nimport { useRef, useMemo } from 'react';\nimport { GraphQLRequest } from '../types';\nimport { createRequest } from '../utils';\n\n/** Creates a request from a query and variables but preserves reference equality if the key isn't changing */\nexport const useRequest = (\n  query: string | DocumentNode,\n  variables?: any\n): GraphQLRequest => {\n  const prev = useRef<undefined | GraphQLRequest>(undefined);\n\n  return useMemo(() => {\n    const request = createRequest(query, variables);\n    // We manually ensure reference equality if the key hasn't changed\n    if (prev.current !== undefined && prev.current.key === request.key) {\n      return prev.current;\n    } else {\n      prev.current = request;\n      return request;\n    }\n  }, [query, variables]);\n};\n","import { DocumentNode } from 'graphql';\nimport { useCallback, useMemo } from 'react';\nimport { pipe, concat, fromValue, switchMap, map, scan } from 'wonka';\nimport { useOperator } from 'react-wonka';\n\nimport { useClient } from '../context';\nimport { OperationContext, RequestPolicy } from '../types';\nimport { CombinedError } from '../utils';\nimport { useRequest } from './useRequest';\nimport { initialState } from './constants';\n\nexport interface UseQueryArgs<V> {\n  query: string | DocumentNode;\n  variables?: V;\n  requestPolicy?: RequestPolicy;\n  pollInterval?: number;\n  context?: Partial<OperationContext>;\n  pause?: boolean;\n}\n\nexport interface UseQueryState<T> {\n  fetching: boolean;\n  stale: boolean;\n  data?: T;\n  error?: CombinedError;\n  extensions?: Record<string, any>;\n}\n\nexport type UseQueryResponse<T> = [\n  UseQueryState<T>,\n  (opts?: Partial<OperationContext>) => void\n];\n\nexport const useQuery = <T = any, V = object>(\n  args: UseQueryArgs<V>\n): UseQueryResponse<T> => {\n  const client = useClient();\n\n  // This creates a request which will keep a stable reference\n  // if request.key doesn't change\n  const request = useRequest(args.query, args.variables);\n\n  // Create a new query-source from client.executeQuery\n  const makeQuery$ = useCallback(\n    (opts?: Partial<OperationContext>) => {\n      return client.executeQuery(request, {\n        requestPolicy: args.requestPolicy,\n        pollInterval: args.pollInterval,\n        ...args.context,\n        ...opts,\n      });\n    },\n    [client, request, args.requestPolicy, args.pollInterval, args.context]\n  );\n\n  const [state, update] = useOperator(\n    query$$ =>\n      pipe(\n        query$$,\n        switchMap(query$ => {\n          if (!query$) return fromValue({ fetching: false });\n\n          return concat([\n            // Initially set fetching to true\n            fromValue({ fetching: true }),\n            pipe(\n              query$,\n              map(({ stale, data, error, extensions }) => ({\n                fetching: false,\n                stale: !!stale,\n                data,\n                error,\n                extensions,\n              }))\n            ),\n            // When the source proactively closes, fetching is set to false\n            fromValue({ fetching: false }),\n          ]);\n        }),\n        // The individual partial results are merged into each previous result\n        scan(\n          (result, partial: { fetching: boolean }) => ({\n            ...result,\n            stale: false,\n            ...partial,\n          }),\n          initialState\n        )\n      ),\n    useMemo(() => (args.pause ? null : makeQuery$()), [args.pause, makeQuery$]),\n    initialState\n  );\n\n  // This is the imperative execute function passed to the user\n  const executeQuery = useCallback(\n    (opts?: Partial<OperationContext>) => update(makeQuery$(opts)),\n    [update, makeQuery$]\n  );\n\n  return [state, executeQuery];\n};\n","import { DocumentNode } from 'graphql';\nimport { useCallback, useRef, useMemo } from 'react';\nimport { pipe, concat, fromValue, switchMap, map, scan } from 'wonka';\nimport { useOperator } from 'react-wonka';\n\nimport { useClient } from '../context';\nimport { CombinedError } from '../utils';\nimport { OperationContext } from '../types';\nimport { useRequest } from './useRequest';\nimport { initialState } from './constants';\n\nexport interface UseSubscriptionArgs<V> {\n  query: DocumentNode | string;\n  variables?: V;\n  pause?: boolean;\n  context?: Partial<OperationContext>;\n}\n\nexport type SubscriptionHandler<T, R> = (prev: R | undefined, data: T) => R;\n\nexport interface UseSubscriptionState<T> {\n  fetching: boolean;\n  stale: boolean;\n  data?: T;\n  error?: CombinedError;\n  extensions?: Record<string, any>;\n}\n\nexport type UseSubscriptionResponse<T> = [\n  UseSubscriptionState<T>,\n  (opts?: Partial<OperationContext>) => void\n];\n\nexport const useSubscription = <T = any, R = T, V = object>(\n  args: UseSubscriptionArgs<V>,\n  handler?: SubscriptionHandler<T, R>\n): UseSubscriptionResponse<R> => {\n  const client = useClient();\n\n  // Update handler on constant ref, since handler changes shouldn't\n  // trigger a new subscription run\n  const handlerRef = useRef(handler);\n  handlerRef.current = handler;\n\n  // This creates a request which will keep a stable reference\n  // if request.key doesn't change\n  const request = useRequest(args.query, args.variables);\n\n  // Create a new subscription-source from client.executeSubscription\n  const makeSubscription$ = useCallback(\n    (opts?: Partial<OperationContext>) => {\n      return client.executeSubscription(request, { ...args.context, ...opts });\n    },\n    [client, request, args.context]\n  );\n\n  const [state, update] = useOperator(\n    subscription$$ =>\n      pipe(\n        subscription$$,\n        switchMap(subscription$ => {\n          if (!subscription$) return fromValue({ fetching: false });\n\n          return concat([\n            // Initially set fetching to true\n            fromValue({ fetching: true }),\n            pipe(\n              subscription$,\n              map(({ stale, data, error, extensions }) => ({\n                fetching: true,\n                stale: !!stale,\n                data,\n                error,\n                extensions,\n              }))\n            ),\n            // When the source proactively closes, fetching is set to false\n            fromValue({ fetching: false }),\n          ]);\n        }),\n        // The individual partial results are merged into each previous result\n        scan((result, partial: any) => {\n          const { current: handler } = handlerRef;\n          // If a handler has been passed, it's used to merge new data in\n          const data =\n            partial.data !== undefined\n              ? typeof handler === 'function'\n                ? handler(result.data, partial.data)\n                : partial.data\n              : result.data;\n          return { ...result, stale: false, ...partial, data };\n        }, initialState)\n      ),\n    useMemo(() => (args.pause ? null : makeSubscription$()), [\n      args.pause,\n      makeSubscription$,\n    ]),\n    initialState\n  );\n\n  // This is the imperative execute function passed to the user\n  const executeSubscription = useCallback(\n    (opts?: Partial<OperationContext>) => update(makeSubscription$(opts)),\n    [update, makeSubscription$]\n  );\n\n  return [state, executeSubscription];\n};\n","import { ReactElement } from 'react';\nimport { DocumentNode } from 'graphql';\nimport { OperationResult, OperationContext } from '../types';\nimport { useMutation, UseMutationState } from '../hooks';\n\nexport interface MutationProps<T, V> {\n  query: DocumentNode | string;\n  children: (arg: MutationState<T, V>) => ReactElement<any>;\n}\n\nexport interface MutationState<T, V> extends UseMutationState<T> {\n  executeMutation: (\n    variables?: V,\n    context?: Partial<OperationContext>\n  ) => Promise<OperationResult<T>>;\n}\n\nexport function Mutation<T = any, V = any>(\n  props: MutationProps<T, V>\n): ReactElement<any> {\n  const [state, executeMutation] = useMutation<T, V>(props.query);\n  return props.children({ ...state, executeMutation });\n}\n","import { ReactElement } from 'react';\nimport { OperationContext } from '../types';\nimport { useQuery, UseQueryArgs, UseQueryState } from '../hooks';\n\nexport interface QueryProps<T, V> extends UseQueryArgs<V> {\n  children: (arg: QueryState<T>) => ReactElement<any>;\n}\n\nexport interface QueryState<T> extends UseQueryState<T> {\n  executeQuery: (opts?: Partial<OperationContext>) => void;\n}\n\nexport function Query<T = any, V = any>(\n  props: QueryProps<T, V>\n): ReactElement<any> {\n  const [state, executeQuery] = useQuery<T, V>(props);\n  return props.children({ ...state, executeQuery });\n}\n","import { ReactElement } from 'react';\nimport { OperationContext } from '../types';\n\nimport {\n  useSubscription,\n  UseSubscriptionArgs,\n  UseSubscriptionState,\n  SubscriptionHandler,\n} from '../hooks';\n\nexport interface SubscriptionProps<T, R, V> extends UseSubscriptionArgs<V> {\n  handler?: SubscriptionHandler<T, R>;\n  children: (arg: SubscriptionState<R>) => ReactElement<any>;\n}\n\nexport interface SubscriptionState<T> extends UseSubscriptionState<T> {\n  executeSubscription: (opts?: Partial<OperationContext>) => void;\n}\n\nexport function Subscription<T = any, R = T, V = any>(\n  props: SubscriptionProps<T, R, V>\n): ReactElement<any> {\n  const [state, executeSubscription] = useSubscription<T, R, V>(\n    props,\n    props.handler\n  );\n  return props.children({ ...state, executeSubscription });\n}\n"],"names":["const","defaultClient","createClient","url","Context","createContext","Provider","Consumer","let","hasWarnedAboutDefault","useClient","client","useContext","process","env","NODE_ENV","console","warn","initialState","fetching","stale","error","undefined","data","extensions","useMutation","query","useState","result","setState","useCallback","variables","context","request","createRequest","toPromise","executeMutation","then","useRequest","prev","useRef","useMemo","current","key","partial","query$","fromValue","concat","map","query$$","scan","switchMap","useQuery","args","makeQuery$","opts","executeQuery","requestPolicy","pollInterval","useOperator","pause","update","subscription$","useSubscription","handler","handlerRef","makeSubscription$","executeSubscription","subscription$$","Mutation","props","children","Query","Subscription"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"urql.js","sources":["../../src/context.ts","../../src/hooks/constants.ts","../../src/hooks/useMutation.ts","../../src/hooks/useSource.ts","../../src/hooks/useRequest.ts","../../src/hooks/useQuery.ts","../../src/hooks/useSubscription.ts","../../src/components/Mutation.ts","../../src/components/Query.ts","../../src/components/Subscription.ts"],"sourcesContent":["import { createContext, useContext } from 'react';\nimport { Client, createClient } from './client';\n\n// We assume some default options here; mainly not to actually be used\n// but not to error catastrophically if someone is just playing around\nconst defaultClient = createClient({ url: '/graphql' });\n\nexport const Context = createContext<Client>(defaultClient);\nexport const Provider = Context.Provider;\nexport const Consumer = Context.Consumer;\n\nlet hasWarnedAboutDefault = false;\n\nexport const useClient = (): Client => {\n  const client = useContext(Context);\n\n  if (\n    process.env.NODE_ENV !== 'production' &&\n    client === defaultClient &&\n    !hasWarnedAboutDefault\n  ) {\n    hasWarnedAboutDefault = true;\n\n    console.warn(\n      \"Default Client: No client has been specified using urql's Provider.\" +\n        'This means that urql will be falling back to defaults including making ' +\n        'requests to `/graphql`.\\n' +\n        \"If that's not what you want, please create a client and add a Provider.\"\n    );\n  }\n\n  return client;\n};\n","export const initialState = {\n  fetching: false,\n  stale: false,\n  error: undefined,\n  data: undefined,\n  extensions: undefined,\n};\n","import { DocumentNode } from 'graphql';\nimport { useState, useCallback } from 'react';\nimport { pipe, toPromise } from 'wonka';\nimport { useClient } from '../context';\nimport { OperationResult, OperationContext } from '../types';\nimport { CombinedError, createRequest } from '../utils';\nimport { initialState } from './constants';\n\nexport interface UseMutationState<T> {\n  fetching: boolean;\n  stale: boolean;\n  data?: T;\n  error?: CombinedError;\n  extensions?: Record<string, any>;\n}\n\nexport type UseMutationResponse<T, V> = [\n  UseMutationState<T>,\n  (\n    variables?: V,\n    context?: Partial<OperationContext>\n  ) => Promise<OperationResult<T>>\n];\n\nexport const useMutation = <T = any, V = object>(\n  query: DocumentNode | string\n): UseMutationResponse<T, V> => {\n  const client = useClient();\n\n  const [state, setState] = useState<UseMutationState<T>>(initialState);\n\n  const executeMutation = useCallback(\n    (variables?: V, context?: Partial<OperationContext>) => {\n      setState({ ...initialState, fetching: true });\n\n      const request = createRequest(query, variables as any);\n\n      return pipe(\n        client.executeMutation(request, context || {}),\n        toPromise\n      ).then(result => {\n        setState({\n          fetching: false,\n          stale: !!result.stale,\n          data: result.data,\n          error: result.error,\n          extensions: result.extensions,\n        });\n        return result;\n      });\n    },\n    [client, query, setState]\n  );\n\n  return [state, executeMutation];\n};\n","/* eslint-disable @typescript-eslint/no-use-before-define */\n/* eslint-disable react-hooks/exhaustive-deps */\n\nimport { useMemo, useEffect } from 'react';\nimport { Subscription, Unsubscribe, useSubscription } from 'use-subscription';\n\nimport {\n  Source,\n  fromValue,\n  makeSubject,\n  pipe,\n  map,\n  concat,\n  onPush,\n  publish,\n  subscribe,\n} from 'wonka';\n\nexport const useSource = <T>(source: Source<T>, init: T): T =>\n  useSubscription(\n    useMemo((): Subscription<T> => {\n      let hasUpdate = false;\n      let currentValue: T = init;\n\n      const updateValue = pipe(\n        source,\n        onPush(value => {\n          currentValue = value;\n        })\n      );\n\n      return {\n        getCurrentValue(): T {\n          if (!hasUpdate) publish(updateValue).unsubscribe();\n          return currentValue;\n        },\n        subscribe(onValue: () => void): Unsubscribe {\n          return pipe(\n            updateValue,\n            subscribe(() => {\n              hasUpdate = true;\n              onValue();\n              hasUpdate = false;\n            })\n          ).unsubscribe as Unsubscribe;\n        },\n      };\n    }, [source])\n  );\n\nexport const useBehaviourSubject = <T>(value: T) => {\n  const state = useMemo((): [Source<T>, (value: T) => void] => {\n    let prevValue = value;\n\n    const subject = makeSubject<T>();\n    const prevValue$ = pipe(\n      fromValue(value),\n      map(() => prevValue)\n    );\n\n    const source = concat([prevValue$, subject.source]);\n\n    const next = (value: T) => {\n      subject.next((prevValue = value));\n    };\n\n    return [source, next];\n  }, []);\n\n  useEffect(() => {\n    state[1](value);\n  }, [state, value]);\n\n  return state;\n};\n","import { DocumentNode } from 'graphql';\nimport { useRef, useMemo } from 'react';\nimport { GraphQLRequest } from '../types';\nimport { createRequest } from '../utils';\n\n/** Creates a request from a query and variables but preserves reference equality if the key isn't changing */\nexport const useRequest = (\n  query: string | DocumentNode,\n  variables?: any\n): GraphQLRequest => {\n  const prev = useRef<undefined | GraphQLRequest>(undefined);\n\n  return useMemo(() => {\n    const request = createRequest(query, variables);\n    // We manually ensure reference equality if the key hasn't changed\n    if (prev.current !== undefined && prev.current.key === request.key) {\n      return prev.current;\n    } else {\n      prev.current = request;\n      return request;\n    }\n  }, [query, variables]);\n};\n","import { DocumentNode } from 'graphql';\nimport { useCallback, useMemo } from 'react';\nimport { pipe, concat, fromValue, switchMap, map, scan } from 'wonka';\n\nimport { useClient } from '../context';\nimport { OperationContext, RequestPolicy } from '../types';\nimport { CombinedError } from '../utils';\nimport { useSource, useBehaviourSubject } from './useSource';\nimport { useRequest } from './useRequest';\nimport { initialState } from './constants';\n\nexport interface UseQueryArgs<V> {\n  query: string | DocumentNode;\n  variables?: V;\n  requestPolicy?: RequestPolicy;\n  pollInterval?: number;\n  context?: Partial<OperationContext>;\n  pause?: boolean;\n}\n\nexport interface UseQueryState<T> {\n  fetching: boolean;\n  stale: boolean;\n  data?: T;\n  error?: CombinedError;\n  extensions?: Record<string, any>;\n}\n\nexport type UseQueryResponse<T> = [\n  UseQueryState<T>,\n  (opts?: Partial<OperationContext>) => void\n];\n\nexport const useQuery = <T = any, V = object>(\n  args: UseQueryArgs<V>\n): UseQueryResponse<T> => {\n  const client = useClient();\n\n  // This creates a request which will keep a stable reference\n  // if request.key doesn't change\n  const request = useRequest(args.query, args.variables);\n\n  // Create a new query-source from client.executeQuery\n  const makeQuery$ = useCallback(\n    (opts?: Partial<OperationContext>) => {\n      return client.executeQuery(request, {\n        requestPolicy: args.requestPolicy,\n        pollInterval: args.pollInterval,\n        ...args.context,\n        ...opts,\n      });\n    },\n    [client, request, args.requestPolicy, args.pollInterval, args.context]\n  );\n\n  const [query$$, update] = useBehaviourSubject(\n    useMemo(() => (args.pause ? null : makeQuery$()), [args.pause, makeQuery$])\n  );\n\n  const state = useSource(\n    useMemo(() => {\n      return pipe(\n        query$$,\n        switchMap(query$ => {\n          if (!query$) return fromValue({ fetching: false, stale: false });\n\n          return concat([\n            // Initially set fetching to true\n            fromValue({ fetching: true, stale: false }),\n            pipe(\n              query$,\n              map(({ stale, data, error, extensions }) => ({\n                fetching: false,\n                stale: !!stale,\n                data,\n                error,\n                extensions,\n              }))\n            ),\n            // When the source proactively closes, fetching is set to false\n            fromValue({ fetching: false, stale: false }),\n          ]);\n        }),\n        // The individual partial results are merged into each previous result\n        scan(\n          (result, partial) => ({\n            ...result,\n            ...partial,\n          }),\n          initialState\n        )\n      );\n    }, [query$$]),\n    initialState\n  );\n\n  // This is the imperative execute function passed to the user\n  const executeQuery = useCallback(\n    (opts?: Partial<OperationContext>) => update(makeQuery$(opts)),\n    [update, makeQuery$]\n  );\n\n  return [state, executeQuery];\n};\n","import { DocumentNode } from 'graphql';\nimport { useCallback, useRef, useMemo } from 'react';\nimport { pipe, concat, fromValue, switchMap, map, scan } from 'wonka';\n\nimport { useClient } from '../context';\nimport { CombinedError } from '../utils';\nimport { useSource, useBehaviourSubject } from './useSource';\nimport { OperationContext } from '../types';\nimport { useRequest } from './useRequest';\nimport { initialState } from './constants';\n\nexport interface UseSubscriptionArgs<V> {\n  query: DocumentNode | string;\n  variables?: V;\n  pause?: boolean;\n  context?: Partial<OperationContext>;\n}\n\nexport type SubscriptionHandler<T, R> = (prev: R | undefined, data: T) => R;\n\nexport interface UseSubscriptionState<T> {\n  fetching: boolean;\n  stale: boolean;\n  data?: T;\n  error?: CombinedError;\n  extensions?: Record<string, any>;\n}\n\nexport type UseSubscriptionResponse<T> = [\n  UseSubscriptionState<T>,\n  (opts?: Partial<OperationContext>) => void\n];\n\nexport const useSubscription = <T = any, R = T, V = object>(\n  args: UseSubscriptionArgs<V>,\n  handler?: SubscriptionHandler<T, R>\n): UseSubscriptionResponse<R> => {\n  const client = useClient();\n\n  // Update handler on constant ref, since handler changes shouldn't\n  // trigger a new subscription run\n  const handlerRef = useRef(handler);\n  handlerRef.current = handler;\n\n  // This creates a request which will keep a stable reference\n  // if request.key doesn't change\n  const request = useRequest(args.query, args.variables);\n\n  // Create a new subscription-source from client.executeSubscription\n  const makeSubscription$ = useCallback(\n    (opts?: Partial<OperationContext>) => {\n      return client.executeSubscription(request, { ...args.context, ...opts });\n    },\n    [client, request, args.context]\n  );\n\n  const [subscription$$, update] = useBehaviourSubject(\n    useMemo(() => (args.pause ? null : makeSubscription$()), [\n      args.pause,\n      makeSubscription$,\n    ])\n  );\n\n  const state = useSource(\n    useMemo(() => {\n      return pipe(\n        subscription$$,\n        switchMap(subscription$ => {\n          if (!subscription$) return fromValue({ fetching: false });\n\n          return concat([\n            // Initially set fetching to true\n            fromValue({ fetching: true, stale: false }),\n            pipe(\n              subscription$,\n              map(({ stale, data, error, extensions }) => ({\n                fetching: true,\n                stale: !!stale,\n                data,\n                error,\n                extensions,\n              }))\n            ),\n            // When the source proactively closes, fetching is set to false\n            fromValue({ fetching: false, stale: false }),\n          ]);\n        }),\n        // The individual partial results are merged into each previous result\n        scan((result, partial: any) => {\n          const { current: handler } = handlerRef;\n          // If a handler has been passed, it's used to merge new data in\n          const data =\n            partial.data !== undefined\n              ? typeof handler === 'function'\n                ? handler(result.data, partial.data)\n                : partial.data\n              : result.data;\n          return { ...result, ...partial, data };\n        }, initialState)\n      );\n    }, [subscription$$]),\n    initialState\n  );\n\n  // This is the imperative execute function passed to the user\n  const executeSubscription = useCallback(\n    (opts?: Partial<OperationContext>) => update(makeSubscription$(opts)),\n    [update, makeSubscription$]\n  );\n\n  return [state, executeSubscription];\n};\n","import { ReactElement } from 'react';\nimport { DocumentNode } from 'graphql';\nimport { OperationResult, OperationContext } from '../types';\nimport { useMutation, UseMutationState } from '../hooks';\n\nexport interface MutationProps<T, V> {\n  query: DocumentNode | string;\n  children: (arg: MutationState<T, V>) => ReactElement<any>;\n}\n\nexport interface MutationState<T, V> extends UseMutationState<T> {\n  executeMutation: (\n    variables?: V,\n    context?: Partial<OperationContext>\n  ) => Promise<OperationResult<T>>;\n}\n\nexport function Mutation<T = any, V = any>(\n  props: MutationProps<T, V>\n): ReactElement<any> {\n  const [state, executeMutation] = useMutation<T, V>(props.query);\n  return props.children({ ...state, executeMutation });\n}\n","import { ReactElement } from 'react';\nimport { OperationContext } from '../types';\nimport { useQuery, UseQueryArgs, UseQueryState } from '../hooks';\n\nexport interface QueryProps<T, V> extends UseQueryArgs<V> {\n  children: (arg: QueryState<T>) => ReactElement<any>;\n}\n\nexport interface QueryState<T> extends UseQueryState<T> {\n  executeQuery: (opts?: Partial<OperationContext>) => void;\n}\n\nexport function Query<T = any, V = any>(\n  props: QueryProps<T, V>\n): ReactElement<any> {\n  const [state, executeQuery] = useQuery<T, V>(props);\n  return props.children({ ...state, executeQuery });\n}\n","import { ReactElement } from 'react';\nimport { OperationContext } from '../types';\n\nimport {\n  useSubscription,\n  UseSubscriptionArgs,\n  UseSubscriptionState,\n  SubscriptionHandler,\n} from '../hooks';\n\nexport interface SubscriptionProps<T, R, V> extends UseSubscriptionArgs<V> {\n  handler?: SubscriptionHandler<T, R>;\n  children: (arg: SubscriptionState<R>) => ReactElement<any>;\n}\n\nexport interface SubscriptionState<T> extends UseSubscriptionState<T> {\n  executeSubscription: (opts?: Partial<OperationContext>) => void;\n}\n\nexport function Subscription<T = any, R = T, V = any>(\n  props: SubscriptionProps<T, R, V>\n): ReactElement<any> {\n  const [state, executeSubscription] = useSubscription<T, R, V>(\n    props,\n    props.handler\n  );\n  return props.children({ ...state, executeSubscription });\n}\n"],"names":["const","defaultClient","createClient","url","Context","createContext","Provider","Consumer","let","hasWarnedAboutDefault","useClient","client","useContext","process","env","NODE_ENV","console","warn","initialState","fetching","stale","error","undefined","data","extensions","useMutation","query","useState","result","setState","useCallback","variables","context","request","createRequest","toPromise","executeMutation","then","useSource","source","init","useSubscription","useMemo","hasUpdate","currentValue","updateValue","onPush","value","getCurrentValue","publish","unsubscribe","subscribe","onValue","useBehaviourSubject","state","prevValue","subject","makeSubject","prevValue$","map","fromValue","concat","next","useEffect","useRequest","prev","useRef","current","key","partial","query$","useQuery","args","makeQuery$","opts","executeQuery","requestPolicy","pollInterval","pause","scan","switchMap","query$$","update","subscription$","handler","handlerRef","makeSubscription$","executeSubscription","subscription$$","Mutation","props","children","Query","Subscription"],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/urql/dist/types/hooks/useSource.d.ts b/node_modules/urql/dist/types/hooks/useSource.d.ts
new file mode 100644
index 0000000..0429a91
--- /dev/null
+++ b/node_modules/urql/dist/types/hooks/useSource.d.ts
@@ -0,0 +1,3 @@
+import { Source } from 'wonka';
+export declare const useSource: <T>(source: Source<T>, init: T) => T;
+export declare const useBehaviourSubject: <T>(value: T) => [Source<T>, (value: T) => void];
